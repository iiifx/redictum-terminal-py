#!/usr/bin/env python3
"""Redictum Terminal — voice-to-text CLI for Linux."""
from __future__ import annotations

import argparse
import atexit
import json
import logging
import math
import os
import signal
import shutil
import struct
import subprocess
import sys
import tempfile
import threading
import time
from datetime import datetime
from pathlib import Path
from typing import Any, Callable

try:
    from rich.console import Console
    _console: Console | None = Console(highlight=False)
except ImportError:
    _console = None

VERSION = "1.0.0-dev"

EXIT_OK = 0
EXIT_ERROR = 1

STATE_IDLE = "idle"
STATE_RECORDING = "recording"
STATE_PROCESSING = "processing"

PID_FILENAME = "redictum.pid"
LOG_FILENAME = "redictum.log"
STOP_TIMEOUT = 3.0

PATH_KEYS = ("whisper_cli", "whisper_model")
REQUIRED_DIRS = ("audio", "transcripts", "logs")

APT_PACKAGES: dict[str, str] = {
    "ffmpeg": "ffmpeg",
    "xclip": "xclip",
    "xdotool": "xdotool",
    "cmake": "cmake",
    "build-essential": "build-essential",
    "git": "git",
}

PIP_PACKAGES: tuple[str, ...] = ("pynput", "rich")

DEFAULT_CONFIG: dict[str, Any] = {
    "whisper_cli": "~/whisper.cpp/build/bin/whisper-cli",
    "whisper_model": "~/whisper.cpp/models/ggml-large-v3-turbo-q5_0.bin",
    "whisper_language": "ru",
    "whisper_prompt": "",
    "transcription_timeout": 120,
    "sample_rate": 16000,
    "channels": 1,
    "arecord_device": "pulse",
    "normalize_audio": True,
    "hotkey": "Insert",
    "hold_delay": 1.0,
    "auto_paste": True,
    "text_prefix": "",
    "text_postfix": "",
    "sound_feedback": True,
    "sound_volume": 50,
    "max_audio_files": 50,
}


class RedictumError(Exception):
    """Base exception for Redictum Terminal errors."""


def _rprint(text: str) -> None:
    """Print with rich markup if available, plain print otherwise."""
    if _console is not None:
        _console.print(text)
    else:
        import re
        print(re.sub(r"\[/?[^\]]*\]", "", text))


# ---------------------------------------------------------------------------
# ConfigManager
# ---------------------------------------------------------------------------

class ConfigManager:
    """Manages config.json: generation, loading, merging with defaults.

    Config file lives next to the script. Missing keys are filled from
    DEFAULT_CONFIG; extra keys in the user file are preserved.
    """

    def __init__(self, script_dir: Path) -> None:
        self._path = script_dir / "config.json"

    @property
    def path(self) -> Path:
        """Return the resolved config file path."""
        return self._path

    def load(self) -> dict[str, Any]:
        """Load config from disk or generate a default one.

        Returns:
            Merged configuration dictionary.

        Raises:
            RedictumError: If config.json exists but contains invalid JSON.
        """
        if not self._path.exists():
            self._write_default()
            return self._expand_paths(dict(DEFAULT_CONFIG))

        try:
            raw = self._path.read_text(encoding="utf-8")
            user_config: dict[str, Any] = json.loads(raw)
        except json.JSONDecodeError as exc:
            raise RedictumError(
                f"Invalid JSON in {self._path}: {exc}"
            ) from exc

        merged = dict(DEFAULT_CONFIG)
        merged.update(user_config)
        return self._expand_paths(merged)

    def update(self, updates: dict[str, Any]) -> None:
        """Update specific keys in config.json, preserving other values.

        Args:
            updates: Dictionary of keys to update.
        """
        if self._path.exists():
            raw = self._path.read_text(encoding="utf-8")
            config: dict[str, Any] = json.loads(raw)
        else:
            config = dict(DEFAULT_CONFIG)
        config.update(updates)
        self._path.write_text(
            json.dumps(config, indent=4, ensure_ascii=False) + "\n",
            encoding="utf-8",
        )

    # -- private helpers -----------------------------------------------------

    def _write_default(self) -> None:
        """Write DEFAULT_CONFIG to config.json with pretty formatting."""
        self._path.write_text(
            json.dumps(DEFAULT_CONFIG, indent=4, ensure_ascii=False) + "\n",
            encoding="utf-8",
        )

    @staticmethod
    def _expand_paths(config: dict[str, Any]) -> dict[str, Any]:
        """Expand ``~`` in path-valued keys."""
        for key in PATH_KEYS:
            if key in config and isinstance(config[key], str):
                config[key] = str(Path(config[key]).expanduser())
        return config


# ---------------------------------------------------------------------------
# DirectoryManager
# ---------------------------------------------------------------------------

class DirectoryManager:
    """Creates required working directories next to the script.

    Directories: audio/, transcripts/, logs/.
    """

    def __init__(self, script_dir: Path) -> None:
        self._script_dir = script_dir

    def ensure(self) -> None:
        """Create all required directories if they don't exist."""
        for name in REQUIRED_DIRS:
            (self._script_dir / name).mkdir(exist_ok=True)


# ---------------------------------------------------------------------------
# Stubs
# ---------------------------------------------------------------------------

class Diagnostics:
    """Check external dependencies and offer auto-installation.

    Stage 1 — critical checks (fail fast): Python 3.10+, Linux, PulseAudio,
    ALSA, X11. If any fail, raise RedictumError.

    Stage 2 — installable dependencies (auto-fix): apt and pip packages.
    Offer to install missing ones, user confirms with y/n.

    whisper.cpp — offer auto-install if missing (clone, build, model download).
    """

    def __init__(self, config: dict[str, Any], config_mgr: ConfigManager) -> None:
        self._config = config
        self._config_mgr = config_mgr

    # -- Stage 1: critical checks -------------------------------------------

    def run_stage1(self) -> None:
        """Run all critical checks. Raise RedictumError on first failure."""
        _rprint("[bold]Checking dependencies...[/bold]")
        self._check_python()
        self._check_linux()
        self._check_pulseaudio()
        self._check_alsa()
        self._check_x11()

    def _check_python(self) -> None:
        ver = sys.version_info
        label = f"Python {ver.major}.{ver.minor}.{ver.micro}"
        if ver >= (3, 10):
            _rprint(f"  [green]\u2713[/green] {label}")
        else:
            _rprint(f"  [red]\u2717[/red] {label}")
            raise RedictumError(
                f"Python 3.10+ is required, found {label}."
            )

    def _check_linux(self) -> None:
        if sys.platform == "linux":
            _rprint("  [green]\u2713[/green] Linux")
        else:
            _rprint(f"  [red]\u2717[/red] Linux — detected {sys.platform}")
            raise RedictumError(
                f"Linux is required, detected platform: {sys.platform}."
            )

    def _check_pulseaudio(self) -> None:
        if shutil.which("paplay"):
            _rprint("  [green]\u2713[/green] PulseAudio (paplay)")
        else:
            _rprint("  [red]\u2717[/red] PulseAudio (paplay) \u2014 not found")
            raise RedictumError(
                "PulseAudio (paplay) is required but not found.\n"
                "Install it manually: sudo apt install pulseaudio-utils"
            )

    def _check_alsa(self) -> None:
        if shutil.which("arecord"):
            _rprint("  [green]\u2713[/green] ALSA (arecord)")
        else:
            _rprint("  [red]\u2717[/red] ALSA (arecord) \u2014 not found")
            raise RedictumError(
                "ALSA (arecord) is required but not found.\n"
                "Install it manually: sudo apt install alsa-utils"
            )

    def _check_x11(self) -> None:
        if os.environ.get("DISPLAY"):
            _rprint("  [green]\u2713[/green] X11 (DISPLAY)")
        else:
            _rprint("  [red]\u2717[/red] X11 (DISPLAY) \u2014 not set")
            raise RedictumError(
                "X11 display is required but DISPLAY is not set.\n"
                "Run from an X11 session or set DISPLAY manually."
            )

    # -- Stage 2: installable dependencies ----------------------------------

    def run_stage2(self) -> None:
        """Find missing installable deps and offer to install them."""
        missing_apt = self._find_missing_apt()
        missing_pip = self._find_missing_pip()

        if not missing_apt and not missing_pip:
            return

        # Print summary of missing packages
        if missing_apt:
            _rprint(f"\nMissing system packages: {', '.join(missing_apt)}")
        if missing_pip:
            _rprint(f"Missing Python packages: {', '.join(missing_pip)}")

        if not self._confirm("\nInstall missing dependencies? [y/n]: "):
            _rprint("[yellow]Skipping installation. Some features may not work.[/yellow]")
            return

        ok = True
        if missing_apt:
            if self._has_apt():
                if not self._install_apt(missing_apt):
                    ok = False
            else:
                _rprint(
                    "[yellow]apt not found. Install manually:[/yellow]\n  "
                    + " ".join(missing_apt)
                )
                ok = False
        if missing_pip:
            if not self._install_pip(missing_pip):
                ok = False

        if ok:
            _rprint("[green]All dependencies installed.[/green]")
        else:
            _rprint("[yellow]Some dependencies failed to install.[/yellow]")

    def _find_missing_apt(self) -> list[str]:
        """Return list of missing apt package names."""
        missing: list[str] = []
        for name, package in APT_PACKAGES.items():
            if name == "build-essential":
                found = self._check_dpkg(package)
            else:
                found = shutil.which(name) is not None
            if found:
                _rprint(f"  [green]\u2713[/green] {name}")
            else:
                _rprint(f"  [red]\u2717[/red] {name}")
                missing.append(package)
        return missing

    def _find_missing_pip(self) -> list[str]:
        """Return list of missing pip package names."""
        missing: list[str] = []
        for package in PIP_PACKAGES:
            try:
                __import__(package)
                _rprint(f"  [green]\u2713[/green] {package}")
            except ImportError:
                _rprint(f"  [red]\u2717[/red] {package}")
                missing.append(package)
        return missing

    def _install_apt(self, packages: list[str]) -> bool:
        """Run sudo apt install for the given packages. Return success."""
        cmd = ["sudo", "apt", "install", "-y", *packages]
        _rprint(f"[dim]Running: {' '.join(cmd)}[/dim]")
        result = subprocess.run(cmd)
        return result.returncode == 0

    def _install_pip(self, packages: list[str]) -> bool:
        """Run pip install for the given packages. Return success."""
        cmd = ["pip", "install", *packages]
        _rprint(f"[dim]Running: {' '.join(cmd)}[/dim]")
        result = subprocess.run(cmd)
        return result.returncode == 0

    def _has_apt(self) -> bool:
        """Check if apt is available (Debian/Ubuntu/Mint)."""
        return shutil.which("apt") is not None

    def _check_dpkg(self, package: str) -> bool:
        """Check if a package is installed via dpkg -s."""
        try:
            result = subprocess.run(
                ["dpkg", "-s", package],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            return result.returncode == 0
        except FileNotFoundError:
            return False

    def _confirm(self, prompt: str) -> bool:
        """Ask the user y/n via input()."""
        try:
            answer = input(prompt).strip().lower()
        except (EOFError, KeyboardInterrupt):
            print()
            return False
        return answer in ("y", "yes")

    # -- whisper.cpp: warning only ------------------------------------------

    def check_whisper(self) -> None:
        """Check whisper.cpp and model, offer installation if missing."""
        cli_path = self._config.get("whisper_cli", "")
        model_path = self._config.get("whisper_model", "")
        cli_ok = bool(cli_path) and Path(cli_path).exists()
        model_ok = bool(model_path) and Path(model_path).exists()

        if cli_ok:
            _rprint("  [green]\u2713[/green] whisper.cpp")
        else:
            _rprint(f"  [yellow]\u26a0[/yellow] whisper.cpp not found at {cli_path}")

        if model_ok:
            _rprint("  [green]\u2713[/green] whisper model")
        else:
            _rprint(f"  [yellow]\u26a0[/yellow] whisper model not found at {model_path}")

        if cli_ok and model_ok:
            return

        if self._confirm("\nInstall whisper.cpp? [y/n]: "):
            installer = WhisperInstaller(self._config_mgr)
            installer.install()
        else:
            _rprint(
                "[yellow]Skipping. You can install later with:[/yellow] "
                "[bold]./redictum install-whisper[/bold]"
            )


class WhisperInstaller:
    """Install whisper.cpp from source and download a model."""

    REPO_URL = "https://github.com/ggerganov/whisper.cpp.git"
    HF_BASE = "https://huggingface.co/ggerganov/whisper.cpp/resolve/main"

    MODELS: list[tuple[str, str, str]] = [
        ("large-v3-turbo-q5_0", "ggml-large-v3-turbo-q5_0.bin", "~547 MB, best speed/quality"),
        ("large-v3-turbo", "ggml-large-v3-turbo.bin", "~1.6 GB, full turbo"),
        ("large-v3", "ggml-large-v3.bin", "~3.1 GB, highest quality"),
        ("medium", "ggml-medium.bin", "~1.5 GB"),
        ("small", "ggml-small.bin", "~466 MB"),
        ("base", "ggml-base.bin", "~142 MB"),
        ("tiny", "ggml-tiny.bin", "~75 MB, fastest"),
    ]

    def __init__(self, config_mgr: ConfigManager) -> None:
        self._config_mgr = config_mgr
        self._install_dir = Path.home() / "whisper.cpp"

    def install(self) -> None:
        """Run the full whisper.cpp installation flow."""
        _rprint("\n[bold]whisper.cpp Installer[/bold]")

        cli_path = self._install_dir / "build" / "bin" / "whisper-cli"
        if cli_path.exists():
            _rprint(f"  [green]\u2713[/green] whisper-cli already exists at {cli_path}")
            if not self._confirm("  Rebuild whisper.cpp? [y/n]: "):
                model_path = self._ensure_model()
                self._update_config(cli_path, model_path)
                return
        else:
            self._clone()

        use_cuda = self._detect_cuda()
        self._build(use_cuda)

        cli_path = self._install_dir / "build" / "bin" / "whisper-cli"
        if not cli_path.exists():
            raise RedictumError(
                f"Build completed but whisper-cli not found at {cli_path}"
            )

        model_path = self._select_and_download()
        self._update_config(cli_path, model_path)
        _rprint("\n[green]whisper.cpp installation complete![/green]")

    def _confirm(self, prompt: str) -> bool:
        """Ask the user y/n."""
        try:
            answer = input(prompt).strip().lower()
        except (EOFError, KeyboardInterrupt):
            print()
            return False
        return answer in ("y", "yes")

    def _clone(self) -> None:
        """Clone or update the whisper.cpp repository."""
        if self._install_dir.exists():
            _rprint(f"  [yellow]\u26a0[/yellow] {self._install_dir} exists, pulling latest...")
            result = subprocess.run(
                ["git", "-C", str(self._install_dir), "pull"],
                capture_output=True,
                text=True,
            )
            if result.returncode != 0:
                raise RedictumError(f"git pull failed: {result.stderr[:200]}")
            _rprint("  [green]\u2713[/green] Repository updated")
        else:
            _rprint(f"  Cloning whisper.cpp to {self._install_dir}...")
            result = subprocess.run(
                ["git", "clone", "--depth", "1", self.REPO_URL,
                 str(self._install_dir)],
            )
            if result.returncode != 0:
                raise RedictumError("git clone failed")
            _rprint("  [green]\u2713[/green] Repository cloned")

    def _detect_cuda(self) -> bool:
        """Check if CUDA toolkit is available."""
        if shutil.which("nvcc"):
            _rprint("  [green]\u2713[/green] CUDA detected, building with GPU support")
            return True
        _rprint("  [dim]CUDA not found, building CPU-only[/dim]")
        return False

    def _build(self, use_cuda: bool) -> None:
        """Configure and build whisper.cpp."""
        _rprint("  Configuring build...")
        cmake_args = [
            "cmake", "-B", "build",
            "-DCMAKE_BUILD_TYPE=Release",
        ]
        if use_cuda:
            cmake_args.append("-DGGML_CUDA=ON")

        result = subprocess.run(
            cmake_args,
            cwd=str(self._install_dir),
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            raise RedictumError(
                f"cmake configure failed:\n{result.stderr[:500]}"
            )
        _rprint("  [green]\u2713[/green] Build configured")

        jobs = os.cpu_count() or 1
        _rprint(f"  Building whisper.cpp ({jobs} jobs, may take several minutes)...")
        result = subprocess.run(
            ["cmake", "--build", "build", "--config", "Release",
             "-j", str(jobs)],
            cwd=str(self._install_dir),
        )
        if result.returncode != 0:
            if use_cuda:
                _rprint("  [yellow]\u26a0[/yellow] CUDA build failed, retrying CPU-only...")
                shutil.rmtree(self._install_dir / "build", ignore_errors=True)
                self._build(use_cuda=False)
                return
            raise RedictumError("cmake build failed")
        _rprint("  [green]\u2713[/green] Build complete")

    def _select_and_download(self) -> Path:
        """Let the user pick a model and download it."""
        _rprint("\n  [bold]Available models:[/bold]")
        for i, (name, _filename, desc) in enumerate(self.MODELS, 1):
            marker = " [bold](recommended)[/bold]" if i == 1 else ""
            _rprint(f"    {i}. {name} — {desc}{marker}")

        while True:
            try:
                choice = input(
                    f"\n  Select model [1-{len(self.MODELS)}, default=1]: "
                ).strip()
            except (EOFError, KeyboardInterrupt):
                print()
                choice = ""
            if not choice:
                choice = "1"
            try:
                idx = int(choice) - 1
                if 0 <= idx < len(self.MODELS):
                    break
            except ValueError:
                pass
            _rprint(f"  [red]Invalid choice, enter 1-{len(self.MODELS)}[/red]")

        _name, filename, _desc = self.MODELS[idx]
        return self._download_model(filename)

    def _download_model(self, filename: str) -> Path:
        """Download a model file from Hugging Face."""
        models_dir = self._install_dir / "models"
        models_dir.mkdir(exist_ok=True)
        model_path = models_dir / filename

        if model_path.exists():
            _rprint(f"  [green]\u2713[/green] Model already downloaded: {filename}")
            return model_path

        url = f"{self.HF_BASE}/{filename}"
        _rprint(f"  Downloading {filename}...")

        # Prefer curl, fall back to wget
        if shutil.which("curl"):
            cmd = ["curl", "-L", "-o", str(model_path), "--progress-bar", url]
        elif shutil.which("wget"):
            cmd = ["wget", "-O", str(model_path), "--show-progress", "-q", url]
        else:
            raise RedictumError(
                "Neither curl nor wget found. Install one: "
                "sudo apt install curl"
            )

        result = subprocess.run(cmd)
        if result.returncode != 0 or not model_path.exists():
            # Clean up partial download
            if model_path.exists():
                model_path.unlink()
            raise RedictumError(f"Model download failed: {filename}")

        _rprint(f"  [green]\u2713[/green] Model downloaded: {filename}")
        return model_path

    def _ensure_model(self) -> Path:
        """Check if a model exists, offer download if not."""
        config = self._config_mgr.load()
        model_path_str = config.get("whisper_model", "")
        if model_path_str and Path(model_path_str).exists():
            _rprint(f"  [green]\u2713[/green] Model found: {model_path_str}")
            return Path(model_path_str)
        return self._select_and_download()

    def _update_config(self, cli_path: Path, model_path: Path) -> None:
        """Write whisper paths to config.json."""
        home = str(Path.home())
        cli_str = str(cli_path)
        model_str = str(model_path)
        # Use ~ for readability in config
        if cli_str.startswith(home):
            cli_str = "~" + cli_str[len(home):]
        if model_str.startswith(home):
            model_str = "~" + model_str[len(home):]
        self._config_mgr.update({
            "whisper_cli": cli_str,
            "whisper_model": model_str,
        })
        _rprint("  [green]\u2713[/green] Config updated with whisper paths")


def setup_logging(log_path: Path) -> None:
    """Configure file-based logging. Called at daemon and interactive startup."""
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s [%(levelname)s] %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
        handlers=[logging.FileHandler(log_path, encoding="utf-8")],
    )


class Daemon:
    """Manage daemon lifecycle: PID file, double-fork, signal handling."""

    def __init__(self, pid_path: Path, log_path: Path) -> None:
        self._pid_path = pid_path
        self._log_path = log_path
        self._stop_event = threading.Event()

    # -- PID management ------------------------------------------------------

    def _read_pid(self) -> int | None:
        """Read PID from file. Return None if missing or invalid."""
        try:
            text = self._pid_path.read_text().strip()
            return int(text)
        except (FileNotFoundError, ValueError):
            return None

    def _is_running(self, pid: int) -> bool:
        """Check if process with given PID is alive (signal 0)."""
        try:
            os.kill(pid, 0)
            return True
        except ProcessLookupError:
            return False
        except PermissionError:
            return True

    def _write_pid(self) -> None:
        """Write current PID to the PID file."""
        self._pid_path.write_text(f"{os.getpid()}\n")

    def _cleanup(self) -> None:
        """Remove PID file (atexit callback)."""
        try:
            self._pid_path.unlink()
        except FileNotFoundError:
            pass

    # -- Signal handling -----------------------------------------------------

    def _setup_signals(self) -> None:
        """Register SIGTERM and SIGINT handlers."""
        signal.signal(signal.SIGTERM, self._handle_signal)
        signal.signal(signal.SIGINT, self._handle_signal)

    def _handle_signal(self, signum: int, frame: Any) -> None:
        """Set stop event on signal."""
        self._stop_event.set()
        logging.info("Received signal %s, shutting down...", signum)

    # -- Public API ----------------------------------------------------------

    def start(self, target: Callable[[], None]) -> None:
        """Daemonize via double-fork and run target function.

        Args:
            target: Callable to run in the daemon process.
        """
        # Check for existing daemon
        pid = self._read_pid()
        if pid is not None:
            if self._is_running(pid):
                raise RedictumError(
                    f"Daemon is already running (PID {pid})."
                )
            # Stale PID file — clean up
            self._cleanup()

        # First fork
        try:
            pid = os.fork()
        except OSError as exc:
            raise RedictumError(f"First fork failed: {exc}") from exc
        if pid > 0:
            # Parent — wait briefly for child to settle, then exit
            return

        # Child 1: new session
        os.setsid()
        os.umask(0)

        # Second fork
        try:
            pid = os.fork()
        except OSError as exc:
            sys.exit(1)
        if pid > 0:
            # Child 1 exits
            sys.exit(0)

        # Daemon process (child 2)
        # Redirect std file descriptors
        devnull = os.open(os.devnull, os.O_RDWR)
        os.dup2(devnull, sys.stdin.fileno())

        # Redirect stdout/stderr to log file
        log_fd = os.open(
            str(self._log_path),
            os.O_WRONLY | os.O_CREAT | os.O_APPEND,
            0o644,
        )
        os.dup2(log_fd, sys.stdout.fileno())
        os.dup2(log_fd, sys.stderr.fileno())
        os.close(devnull)
        os.close(log_fd)

        # Setup logging
        setup_logging(self._log_path)

        # Write PID file and register cleanup
        self._write_pid()
        atexit.register(self._cleanup)

        # Setup signal handlers
        self._setup_signals()

        logging.info("Daemon started (PID %d)", os.getpid())

        # Run the target
        try:
            target()
        except Exception:
            logging.exception("Daemon target crashed")
        finally:
            logging.info("Daemon stopped (PID %d)", os.getpid())

    def stop(self) -> None:
        """Send SIGTERM to the running daemon and wait for it to exit."""
        pid = self._read_pid()
        if pid is None:
            raise RedictumError("Daemon is not running (no PID file).")
        if not self._is_running(pid):
            # Stale PID — clean up
            self._cleanup()
            raise RedictumError("Daemon is not running (stale PID file removed).")

        os.kill(pid, signal.SIGTERM)

        # Wait for process to exit
        deadline = time.monotonic() + STOP_TIMEOUT
        while time.monotonic() < deadline:
            if not self._is_running(pid):
                return
            time.sleep(0.1)

        _rprint(
            f"[yellow]Warning: daemon (PID {pid}) did not exit within "
            f"{STOP_TIMEOUT}s after SIGTERM.[/yellow]"
        )

    def status(self) -> int | None:
        """Return PID if daemon is running, None otherwise. Cleans stale PID."""
        pid = self._read_pid()
        if pid is None:
            return None
        if self._is_running(pid):
            return pid
        # Stale PID
        self._cleanup()
        return None

    @property
    def stop_event(self) -> threading.Event:
        """Event for the main loop to wait on."""
        return self._stop_event


class AudioRecorder:
    """Record microphone audio via arecord."""

    def __init__(
        self, output_dir: Path, sample_rate: int, channels: int, device: str
    ) -> None:
        self._output_dir = output_dir
        self._sample_rate = sample_rate
        self._channels = channels
        self._device = device
        self._process: subprocess.Popen[bytes] | None = None
        self._current_file: Path | None = None

    def start(self) -> None:
        """Begin recording audio to a timestamped WAV file."""
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        self._current_file = self._output_dir / f"rec_{ts}.wav"
        self._process = subprocess.Popen(
            [
                "arecord",
                "-D", self._device,
                "-f", "S16_LE",
                "-r", str(self._sample_rate),
                "-c", str(self._channels),
                "-t", "wav",
                str(self._current_file),
            ],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        logging.info("Recording started: %s", self._current_file.name)

    def stop(self) -> Path | None:
        """Stop recording and return the path to the WAV file.

        Returns:
            Path to the recorded WAV file, or None on failure.
        """
        if self._process is None:
            return None
        self._process.terminate()
        try:
            self._process.wait(timeout=5)
        except subprocess.TimeoutExpired:
            self._process.kill()
            self._process.wait()
        self._process = None

        path = self._current_file
        self._current_file = None
        if path is None or not path.exists() or path.stat().st_size == 0:
            if path and path.exists():
                path.unlink()
            return None
        logging.info("Recording stopped: %s", path.name)
        return path

    def cancel(self) -> None:
        """Terminate recording and delete the file. For graceful shutdown."""
        if self._process is not None:
            self._process.terminate()
            try:
                self._process.wait(timeout=2)
            except subprocess.TimeoutExpired:
                self._process.kill()
                self._process.wait()
            self._process = None
        if self._current_file and self._current_file.exists():
            self._current_file.unlink()
            self._current_file = None


class AudioProcessor:
    """Normalize audio via ffmpeg."""

    def normalize(self, input_path: Path) -> Path:
        """Normalize audio levels of the given file.

        Args:
            input_path: Path to the raw audio file.

        Returns:
            Path to the normalized audio file.

        Raises:
            RedictumError: If ffmpeg fails.
        """
        output_path = input_path.with_stem(input_path.stem + "_norm")
        try:
            result = subprocess.run(
                [
                    "ffmpeg",
                    "-i", str(input_path),
                    "-af", "loudnorm",
                    "-ar", "16000",
                    "-ac", "1",
                    "-y",
                    str(output_path),
                ],
                stderr=subprocess.PIPE,
                stdout=subprocess.DEVNULL,
                timeout=60,
            )
        except subprocess.TimeoutExpired as exc:
            raise RedictumError("ffmpeg normalization timed out") from exc
        if result.returncode != 0:
            raise RedictumError(
                f"ffmpeg normalization failed (code {result.returncode}): "
                f"{result.stderr.decode(errors='replace')[:200]}"
            )
        logging.info(
            "Audio normalized: %s -> %s", input_path.name, output_path.name
        )
        return output_path


class Transcriber:
    """Transcribe audio via whisper.cpp CLI."""

    BLANK_MARKERS = {"[BLANK_AUDIO]", "[ЗВУК]", "(silence)"}

    def __init__(
        self,
        whisper_cli: str,
        model_path: str,
        language: str,
        prompt: str = "",
        timeout: int = 120,
    ) -> None:
        self._cli = whisper_cli
        self._model = model_path
        self._language = language
        self._prompt = prompt
        self._timeout = timeout

    def transcribe(self, audio_path: Path) -> str:
        """Transcribe the given audio file to text.

        Args:
            audio_path: Path to the audio file.

        Returns:
            Transcribed text string (empty if nothing useful detected).

        Raises:
            RedictumError: If whisper-cli fails or times out.
        """
        cmd = [
            self._cli,
            "-m", self._model,
            "-l", self._language,
            "-f", str(audio_path),
            "--no-timestamps",
            "-np",
        ]
        if self._prompt:
            cmd.extend(["--prompt", self._prompt])

        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self._timeout,
            )
        except subprocess.TimeoutExpired as exc:
            raise RedictumError(
                f"Transcription timed out after {self._timeout}s"
            ) from exc

        if result.returncode != 0:
            raise RedictumError(
                f"whisper-cli failed (code {result.returncode}): "
                f"{result.stderr[:200]}"
            )

        text = result.stdout.strip()
        # Filter blank audio artifacts
        if not text or text in self.BLANK_MARKERS:
            return ""
        return text


class ClipboardManager:
    """Copy text to clipboard and optionally paste via xdotool."""

    def copy(self, text: str) -> None:
        """Copy text to the system clipboard via xclip."""
        subprocess.run(
            ["xclip", "-selection", "clipboard"],
            input=text.encode("utf-8"),
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )

    def paste(self) -> None:
        """Simulate Ctrl+V to paste from clipboard."""
        time.sleep(0.05)
        subprocess.run(
            ["xdotool", "key", "--clearmodifiers", "ctrl+v"],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )

    def get_clipboard(self) -> str:
        """Read current clipboard contents for save/restore."""
        try:
            result = subprocess.run(
                ["xclip", "-selection", "clipboard", "-o"],
                capture_output=True,
                text=True,
                timeout=5,
            )
            return result.stdout if result.returncode == 0 else ""
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return ""


class SoundNotifier:
    """Generate and play WAV feedback tones via paplay."""

    FREQ_START = 440        # A4 — recording started
    FREQ_PROCESSING = 660   # E5 — transcription in progress
    FREQ_DONE = 880         # A5 — pipeline complete
    FREQ_ERROR = 330        # E4 — error

    DURATION = 0.15         # seconds
    SAMPLE_RATE = 44100

    def __init__(self, volume: int = 50) -> None:
        self._volume = max(0, min(100, volume))
        self._temp_dir = Path(tempfile.mkdtemp(prefix="redictum_"))
        self._sounds: dict[str, Path] = {}
        self._generate_all()

    def _generate_all(self) -> None:
        """Generate all feedback tone WAV files."""
        self._sounds["start"] = self._generate_wav("start.wav", self.FREQ_START)
        self._sounds["processing"] = self._generate_wav("processing.wav", self.FREQ_PROCESSING)
        self._sounds["done"] = self._generate_wav("done.wav", self.FREQ_DONE)
        self._sounds["error"] = self._generate_wav("error.wav", self.FREQ_ERROR)

    def _generate_wav(self, filename: str, frequency: float) -> Path:
        """Generate a sine-wave WAV file.

        Args:
            filename: Output filename.
            frequency: Tone frequency in Hz.

        Returns:
            Path to the generated WAV file.
        """
        num_samples = int(self.SAMPLE_RATE * self.DURATION)
        amplitude = 16000

        # Generate PCM samples
        pcm_data = b""
        for i in range(num_samples):
            sample = int(amplitude * math.sin(2 * math.pi * frequency * i / self.SAMPLE_RATE))
            pcm_data += struct.pack("<h", sample)

        # Build WAV file
        data_size = len(pcm_data)
        file_size = 36 + data_size
        wav_header = struct.pack(
            "<4sI4s4sIHHIIHH4sI",
            b"RIFF", file_size, b"WAVE",
            b"fmt ", 16,             # chunk size
            1,                       # PCM format
            1,                       # mono
            self.SAMPLE_RATE,        # sample rate
            self.SAMPLE_RATE * 2,    # byte rate (sample_rate * channels * bytes_per_sample)
            2,                       # block align (channels * bytes_per_sample)
            16,                      # bits per sample
            b"data", data_size,
        )

        path = self._temp_dir / filename
        path.write_bytes(wav_header + pcm_data)
        return path

    def _play(self, name: str) -> None:
        """Play a named tone via paplay (non-blocking)."""
        wav_path = self._sounds.get(name)
        if wav_path is None or not wav_path.exists():
            return
        vol_scaled = int(self._volume / 100 * 65536)
        try:
            subprocess.Popen(
                ["paplay", f"--volume={vol_scaled}", str(wav_path)],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
        except FileNotFoundError:
            pass

    def play_start(self) -> None:
        """Play the 'recording started' tone."""
        self._play("start")

    def play_processing(self) -> None:
        """Play the 'transcription in progress' tone."""
        self._play("processing")

    def play_stop(self) -> None:
        """Play the 'pipeline complete' tone."""
        self._play("done")

    def play_error(self) -> None:
        """Play the 'error occurred' tone."""
        self._play("error")

    def cleanup(self) -> None:
        """Remove temporary WAV files."""
        shutil.rmtree(self._temp_dir, ignore_errors=True)


class HotkeyListener:
    """Push-to-talk hotkey listener via pynput.

    Hold the key for hold_delay seconds to start recording.
    Release the key to trigger processing.
    """

    # Mapping of config string names to pynput Key attributes
    _KEY_MAP: dict[str, str] = {
        "insert": "insert",
        "delete": "delete",
        "home": "home",
        "end": "end",
        "page_up": "page_up",
        "page_down": "page_down",
        "space": "space",
        "enter": "enter",
        "tab": "tab",
        "backspace": "backspace",
        "pause": "pause",
        "scroll_lock": "scroll_lock",
        "print_screen": "print_screen",
        "caps_lock": "caps_lock",
        "num_lock": "num_lock",
        "escape": "esc",
        "esc": "esc",
    }

    def __init__(self, hotkey: str, hold_delay: float) -> None:
        self._hotkey = hotkey
        self._hold_delay = hold_delay
        self._target_key: Any = None  # set in start() after pynput import
        self._listener: Any = None
        self._hold_timer: threading.Timer | None = None
        self._is_holding = False
        self._on_hold: Callable[[], None] | None = None
        self._on_release: Callable[[], None] | None = None

    def start(self, on_hold: Callable[[], None], on_release: Callable[[], None]) -> None:
        """Start listening for the push-to-talk hotkey.

        Args:
            on_hold: Called when key is held longer than hold_delay.
            on_release: Called when key is released after hold was triggered.
        """
        from pynput.keyboard import Listener

        self._on_hold = on_hold
        self._on_release = on_release
        self._target_key = self._parse_key(self._hotkey)
        self._listener = Listener(
            on_press=self._on_press,
            on_release=self._on_key_release,
        )
        self._listener.start()
        logging.info(
            "Hotkey listener started: %s (hold %.1fs)",
            self._hotkey, self._hold_delay,
        )

    def stop(self) -> None:
        """Stop the hotkey listener and cancel any pending timer."""
        if self._hold_timer is not None:
            self._hold_timer.cancel()
            self._hold_timer = None
        if self._listener is not None:
            self._listener.stop()
            self._listener = None

    def _on_press(self, key: Any) -> None:
        """Handle key press: start hold timer if target key."""
        if self._key_matches(key) and not self._is_holding and self._hold_timer is None:
            self._hold_timer = threading.Timer(self._hold_delay, self._fire_hold)
            self._hold_timer.daemon = True
            self._hold_timer.start()

    def _fire_hold(self) -> None:
        """Called when hold_delay expires — trigger on_hold callback."""
        self._is_holding = True
        self._hold_timer = None
        if self._on_hold:
            self._on_hold()

    def _on_key_release(self, key: Any) -> None:
        """Handle key release: cancel timer or trigger on_release."""
        if not self._key_matches(key):
            return
        if self._hold_timer is not None:
            self._hold_timer.cancel()
            self._hold_timer = None
        if self._is_holding:
            self._is_holding = False
            if self._on_release:
                self._on_release()

    def _key_matches(self, key: Any) -> bool:
        """Check if pressed key matches the target key."""
        return key == self._target_key

    @classmethod
    def _parse_key(cls, hotkey: str) -> Any:
        """Parse a hotkey string into a pynput Key or KeyCode.

        Supports: "Insert", "F1"-"F20", single characters ("a", "b"), etc.
        """
        from pynput.keyboard import Key, KeyCode

        normalized = hotkey.strip().lower()

        # Function keys: f1-f20
        if normalized.startswith("f") and normalized[1:].isdigit():
            attr = normalized
            if hasattr(Key, attr):
                return getattr(Key, attr)

        # Named keys
        if normalized in cls._KEY_MAP:
            return getattr(Key, cls._KEY_MAP[normalized])

        # Single character
        if len(hotkey.strip()) == 1:
            return KeyCode.from_char(hotkey.strip())

        raise RedictumError(f"Unknown hotkey: '{hotkey}'")


class Housekeeping:
    """Rotate old audio files and manage log files."""

    def __init__(self, audio_dir: Path, max_files: int) -> None:
        self._audio_dir = audio_dir
        self._max_files = max_files

    def rotate_audio(self) -> int:
        """Remove oldest audio files exceeding the limit.

        Returns:
            Number of files removed.
        """
        wav_files = sorted(
            self._audio_dir.glob("*.wav"),
            key=lambda p: p.stat().st_mtime,
        )
        excess = len(wav_files) - self._max_files
        if excess <= 0:
            return 0
        removed = 0
        for path in wav_files[:excess]:
            try:
                path.unlink()
                removed += 1
            except OSError:
                logging.warning("Failed to remove %s", path)
        if removed:
            logging.info("Audio rotation: removed %d old file(s)", removed)
        return removed

    def cleanup_logs(self, logs_dir: Path) -> None:
        """Clean up old log files.

        [Stub — implementation in future iterations.]
        """


def _log_transcript(transcripts_dir: Path, text: str) -> None:
    """Append transcript to a daily file transcripts/YYYY-MM-DD.txt."""
    date_str = datetime.now().strftime("%Y-%m-%d")
    log_file = transcripts_dir / f"{date_str}.txt"
    timestamp = datetime.now().strftime("%H:%M:%S")
    with open(log_file, "a", encoding="utf-8") as f:
        f.write(f"[{timestamp}] {text}\n")


# ---------------------------------------------------------------------------
# RedictumApp — orchestrator
# ---------------------------------------------------------------------------

class RedictumApp:
    """Main application orchestrator that wires all components together."""

    def __init__(self, script_dir: Path) -> None:
        self._script_dir = script_dir
        self._config_mgr = ConfigManager(script_dir)
        self._dir_mgr = DirectoryManager(script_dir)
        self._pid_path = script_dir / PID_FILENAME
        self._log_path = script_dir / "logs" / LOG_FILENAME
        self._config: dict[str, Any] = {}

    def init(self) -> dict[str, Any]:
        """Initialize config, directories, and run diagnostics.

        Returns:
            Loaded configuration dictionary.

        Raises:
            RedictumError: If a critical dependency is missing.
        """
        config = self._config_mgr.load()
        self._dir_mgr.ensure()
        diag = Diagnostics(config, self._config_mgr)
        diag.run_stage1()
        diag.run_stage2()
        diag.check_whisper()
        return config

    def run_interactive(self) -> int:
        """Run in interactive (foreground) mode.

        Returns:
            Exit code.
        """
        self._config = self.init()
        setup_logging(self._log_path)

        stop_event = threading.Event()

        def handle_signal(signum: int, frame: Any) -> None:
            stop_event.set()

        signal.signal(signal.SIGINT, handle_signal)
        signal.signal(signal.SIGTERM, handle_signal)

        _rprint("[bold green]Running in interactive mode.[/bold green] Press Ctrl+C to stop.")
        logging.info("Interactive mode started (PID %d)", os.getpid())
        self._main_loop(stop_event)
        logging.info("Interactive mode stopped.")
        return EXIT_OK

    def run_start(self) -> int:
        """Start the daemon.

        Returns:
            Exit code.
        """
        self._config = self.init()
        daemon = Daemon(self._pid_path, self._log_path)
        _rprint("[bold]Starting daemon...[/bold]")

        def target() -> None:
            self._main_loop(daemon.stop_event)

        daemon.start(target=target)
        return EXIT_OK

    def run_stop(self) -> int:
        """Stop the daemon.

        Returns:
            Exit code.
        """
        daemon = Daemon(self._pid_path, self._log_path)
        daemon.stop()
        _rprint("[green]Daemon stopped.[/green]")
        return EXIT_OK

    def run_status(self) -> int:
        """Print daemon status.

        Returns:
            Exit code.
        """
        daemon = Daemon(self._pid_path, self._log_path)
        pid = daemon.status()
        if pid is not None:
            _rprint(f"[green]Daemon is running[/green] (PID {pid})")
        else:
            _rprint("[yellow]Daemon is not running.[/yellow]")
        return EXIT_OK

    def run_install_whisper(self) -> int:
        """Install whisper.cpp and download a model.

        Returns:
            Exit code.
        """
        self._config = self._config_mgr.load()
        self._dir_mgr.ensure()
        installer = WhisperInstaller(self._config_mgr)
        installer.install()
        return EXIT_OK

    def _main_loop(self, stop_event: threading.Event) -> None:
        """Main loop: push-to-talk → record → normalize → transcribe → paste."""
        cfg = self._config
        audio_dir = self._script_dir / "audio"
        transcripts_dir = self._script_dir / "transcripts"

        # Build pipeline components
        recorder = AudioRecorder(
            audio_dir, cfg["sample_rate"], cfg["channels"], cfg["arecord_device"],
        )
        processor = AudioProcessor()
        transcriber = Transcriber(
            cfg["whisper_cli"],
            cfg["whisper_model"],
            cfg["whisper_language"],
            prompt=cfg.get("whisper_prompt", ""),
            timeout=cfg.get("transcription_timeout", 120),
        )
        clipboard = ClipboardManager()
        notifier = SoundNotifier(volume=cfg.get("sound_volume", 50)) if cfg.get("sound_feedback", True) else None
        housekeeper = Housekeeping(audio_dir, cfg["max_audio_files"])
        listener = HotkeyListener(cfg["hotkey"], cfg["hold_delay"])

        state = STATE_IDLE
        state_lock = threading.Lock()

        def on_hold() -> None:
            nonlocal state
            with state_lock:
                if state != STATE_IDLE:
                    return
                state = STATE_RECORDING
            recorder.start()
            if notifier:
                notifier.play_start()

        def on_release() -> None:
            nonlocal state
            with state_lock:
                if state != STATE_RECORDING:
                    return
                state = STATE_PROCESSING

            def worker() -> None:
                nonlocal state
                try:
                    audio_path = recorder.stop()
                    if notifier:
                        notifier.play_processing()
                    if audio_path is None:
                        logging.warning("Recording produced no audio")
                        return

                    # Normalize
                    if cfg.get("normalize_audio", True):
                        try:
                            audio_path = processor.normalize(audio_path)
                        except RedictumError:
                            logging.exception("Normalization failed, using raw audio")

                    # Transcribe
                    text = transcriber.transcribe(audio_path)
                    if not text:
                        logging.info("Transcription returned empty text")
                        return

                    logging.info("Transcribed: %r", text)

                    # Apply prefix/postfix
                    prefix = cfg.get("text_prefix", "")
                    postfix = cfg.get("text_postfix", "")
                    final_text = f"{prefix}{text}{postfix}"

                    # Log transcript
                    _log_transcript(transcripts_dir, final_text)

                    # Clipboard: save → copy → paste → restore
                    if cfg.get("auto_paste", True):
                        saved = clipboard.get_clipboard()
                        clipboard.copy(final_text)
                        clipboard.paste()
                        # Restore previous clipboard after a short delay
                        time.sleep(0.2)
                        clipboard.copy(saved)
                    else:
                        clipboard.copy(final_text)

                    if notifier:
                        notifier.play_stop()
                    housekeeper.rotate_audio()
                    logging.info("Pipeline complete, state -> idle")
                except RedictumError:
                    logging.exception("Pipeline error")
                    if notifier:
                        notifier.play_error()
                except Exception:
                    logging.exception("Unexpected pipeline error")
                    if notifier:
                        notifier.play_error()
                finally:
                    with state_lock:
                        state = STATE_IDLE

            thread = threading.Thread(target=worker, daemon=True)
            thread.start()

        listener.start(on_hold, on_release)

        # Wait for shutdown signal
        stop_event.wait()

        # Graceful shutdown
        listener.stop()
        if notifier:
            notifier.cleanup()
        with state_lock:
            current = state
        if current == STATE_RECORDING:
            recorder.cancel()
            logging.info("Cancelled recording during shutdown")
        elif current == STATE_PROCESSING:
            logging.info("Waiting for processing to finish...")
            deadline = time.monotonic() + 30
            while time.monotonic() < deadline:
                with state_lock:
                    if state == STATE_IDLE:
                        break
                time.sleep(0.5)

        logging.info("Main loop stopped")


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------

def build_parser() -> argparse.ArgumentParser:
    """Build and return the argument parser.

    Returns:
        Configured ArgumentParser instance.
    """
    parser = argparse.ArgumentParser(
        prog="redictum",
        description="Redictum Terminal — voice-to-text CLI for Linux.",
    )
    parser.add_argument(
        "--version",
        action="version",
        version=f"redictum {VERSION}",
    )

    sub = parser.add_subparsers(dest="command")

    sub.add_parser("start", help="Start the daemon")
    sub.add_parser("stop", help="Stop the daemon")
    sub.add_parser("status", help="Show daemon status")
    sub.add_parser("install-whisper", help="Install whisper.cpp and download a model")

    return parser


def main() -> int:
    """Entry point for Redictum Terminal.

    Returns:
        Exit code (0 = success, 1 = error).
    """
    parser = build_parser()
    args = parser.parse_args()

    script_dir = Path(__file__).resolve().parent
    app = RedictumApp(script_dir)

    try:
        if args.command is None:
            return app.run_interactive()
        if args.command == "start":
            return app.run_start()
        if args.command == "stop":
            return app.run_stop()
        if args.command == "status":
            return app.run_status()
        if args.command == "install-whisper":
            return app.run_install_whisper()
    except RedictumError as exc:
        print(f"Error: {exc}", file=sys.stderr)
        return EXIT_ERROR

    return EXIT_OK


if __name__ == "__main__":
    sys.exit(main())
