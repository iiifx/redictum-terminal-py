#!/usr/bin/env python3
"""Redictum Terminal — voice-to-text CLI for Linux.

Author:  Vitaliy Khomenko, Mojam.co
License: MIT
"""
from __future__ import annotations

import argparse
import atexit
import fcntl
import hashlib
import json
import logging
import math
import os
import platform
import re
import shutil
import signal
import struct
import subprocess
import sys
import tempfile
import threading
import time
from collections.abc import Callable
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any

try:
    from rich.console import Console
    _console: Console | None = Console(highlight=False)
except ImportError:
    _console = None

VERSION = "1.7.0"

EXIT_OK = 0
EXIT_ERROR = 1

STATE_IDLE = "idle"
STATE_RECORDING = "recording"
STATE_PROCESSING = "processing"

PID_FILENAME = "redictum.pid"
STATE_FILENAME = ".state"
STOP_TIMEOUT = 3.0

_verbosity = 0  # -1 = quiet, 0 = normal, 1 = verbose

GITHUB_REPO = "iiifx/redictum-terminal-py"
GITHUB_API_LATEST = f"https://api.github.com/repos/{GITHUB_REPO}/releases/latest"
GITHUB_RELEASE_BASE = f"https://github.com/{GITHUB_REPO}/releases/download"
UPDATE_API_TIMEOUT = 10
UPDATE_DL_TIMEOUT = 60

PATH_KEYS: tuple[tuple[str, ...], ...] = (
    ("dependency", "whisper_cli"),
    ("dependency", "whisper_model"),
)
REQUIRED_DIRS = ("audio", "transcripts", "logs")

AUDIO_SAMPLE_RATE = 16000
AUDIO_CHANNELS = 1
# Default RMS threshold for silence detection (applied to raw audio).
# Typical silence with mic noise: RMS ~50-150. Speech mixed with silence: RMS ~300+.
SILENCE_RMS_THRESHOLD = 200

APT_PACKAGES: dict[str, str] = {
    "xclip": "xclip",
}

PIP_PACKAGES: dict[str, str] = {
    "pynput": "pynput",
}

# Fallback: pip package → apt package (for PEP 668 systems)
PIP_APT_FALLBACK: dict[str, str] = {
    "pynput": "python3-pynput",
}

DEFAULT_CONFIG: dict[str, Any] = {
    "dependency": {
        "whisper_cli": "~/whisper.cpp/build/bin/whisper-cli",
        "whisper_model": "~/whisper.cpp/models/ggml-large-v3-turbo-q5_0.bin",
        "whisper_language": "auto",
        "whisper_prompt": "auto",
        "whisper_timeout": 120,
    },
    "audio": {
        "recording_device": "auto",
        "recording_normalize": True,
        "recording_silence_detection": True,
        "recording_silence_threshold": 200,
        "recording_volume_reduce": True,
        "recording_volume_level": 30,
    },
    "input": {
        "hotkey_key": "Insert",
        "hotkey_hold_delay": 0.6,
        "hotkey_translate_key": "ctrl+Insert",
    },
    "clipboard": {
        "paste_auto": True,
        "paste_prefix": "",
        "paste_postfix": " ",
        "paste_restore_delay": 0.3,
    },
    "notification": {
        "sound_signal_volume": 30,
        "sound_signal_start": True,
        "sound_signal_processing": False,
        "sound_signal_done": True,
        "sound_signal_error": True,
    },
    "storage": {
        "audio_max_files": 50,
        "transcripts_max_files": 50,
        "logs_max_files": 50,
    },
}

DEFAULT_CONFIG_INI: str = """\
# =============================================================================
# Redictum Terminal — Configuration
# =============================================================================

# --- External Dependencies ---------------------------------------------------

[dependency]
# Path to whisper-cli binary
whisper_cli = "~/whisper.cpp/build/bin/whisper-cli"

# Path to whisper model file
whisper_model = "~/whisper.cpp/models/ggml-large-v3-turbo-q5_0.bin"

# Language for transcription: "auto" detects from system locale,
# or set explicitly: "en", "ru", "uk", "de", "fr"
whisper_language = "auto"

# Prompt to guide whisper transcription
# "auto" = select by language (built-in prompts for 15 languages)
# "" = no prompt (disable)
# Custom text = use as-is, regardless of language
whisper_prompt = "auto"

# Maximum time (seconds) to wait for transcription to finish
whisper_timeout = 120

# --- Audio Recording ---------------------------------------------------------

[audio]
# ALSA recording device ("auto" = detect, or "pulse", "default", etc.)
recording_device = "auto"

# Normalize audio via ffmpeg loudnorm before transcription
recording_normalize = true

# Skip transcription if recording contains only silence (RMS energy check)
# Prevents whisper hallucinations on silent recordings
recording_silence_detection = true

# RMS energy threshold for silence detection (applied to raw audio before normalize)
# Typical mic noise: ~50-150, speech with silence: ~300+. Lower = more sensitive
recording_silence_threshold = 200

# Reduce system volume while recording to prevent mic picking up speaker audio
# Useful when music, YouTube, or Meet is playing during recording
recording_volume_reduce = true

# Volume reduction percent (0-100) relative to current level
# Example: 30 means keep 30% of current volume (50% → 15%, 100% → 30%)
# 0 = full mute, 100 = no reduction
recording_volume_level = 30

# --- Input -------------------------------------------------------------------

[input]
# Hold this key to record voice (e.g., "Insert", "F12", "Pause", "scroll_lock")
hotkey_key = "Insert"

# Minimum hold time (seconds) to start recording
hotkey_hold_delay = 0.6

# Hold this key combo to record + translate to English
# Format: "ctrl+Insert", "alt+F12", or "" to disable
hotkey_translate_key = "ctrl+Insert"

# --- Clipboard ---------------------------------------------------------------

[clipboard]
# Automatically paste transcribed text via xdotool (Ctrl+V)
paste_auto = true

# Text to prepend before transcription result (use quotes for whitespace)
paste_prefix = ""

# Text to append after transcription result (use quotes for whitespace)
paste_postfix = " "

# Delay (seconds) before restoring clipboard after paste
# Increase if paste arrives too late on slow systems
paste_restore_delay = 0.3

# --- Notifications -----------------------------------------------------------

[notification]
# Volume level (0-100) for notification sounds
sound_signal_volume = 30

# Play tone when recording starts
sound_signal_start = true

# Play tone during processing
sound_signal_processing = false

# Play tone when transcription is done
sound_signal_done = true

# Play tone on error
sound_signal_error = true

# --- Storage -----------------------------------------------------------------

[storage]
# Maximum number of audio files to keep (oldest are deleted)
audio_max_files = 50

# Maximum number of daily transcript files to keep (oldest are deleted)
transcripts_max_files = 50

# Maximum number of session log files to keep (oldest are deleted)
logs_max_files = 50
"""


class RedictumError(Exception):
    """Base exception for Redictum Terminal errors."""


def _rprint(text: str, level: int = 0) -> None:
    """Print with rich markup if available, plain print otherwise.

    Args:
        text: Text to print (may contain rich markup).
        level: Output level.  ``0`` = normal (suppressed in quiet),
            ``1`` = verbose-only, ``-1`` = critical (always shown).
    """
    if _verbosity < 0 and level == 0:
        return
    if level > 0 and _verbosity < level:
        return
    if _console is not None:
        _console.print(text)
    else:
        print(re.sub(r"\[/?[^\]]*\]", "", text))


def _confirm(prompt: str, default: bool = False) -> bool:
    """Ask the user y/n via input(). Return *default* on empty Enter.

    The hint ``[Y/n]`` or ``[y/N]`` is appended automatically.
    Return False on EOF/Ctrl+C.  In quiet mode returns *default* immediately.
    """
    if _verbosity < 0:
        logging.info("Prompt: %r → %s (quiet auto-default)", prompt, "yes" if default else "no")
        return default
    hint = "[Y/n]" if default else "[y/N]"
    try:
        answer = input(f"{prompt} {hint}: ").strip().lower()
    except (EOFError, KeyboardInterrupt):
        print()
        logging.info("Prompt: %r → no (EOF/interrupt)", prompt)
        return False
    if not answer:
        result = default
    else:
        result = answer in ("y", "yes")
    logging.info("Prompt: %r → %s", prompt, "yes" if result else "no")
    return result


def _compare_versions(a: str, b: str) -> int:
    """Compare semver strings. Return -1 if a < b, 0 if equal, 1 if a > b."""
    ta = tuple(int(x) for x in a.split("."))
    tb = tuple(int(x) for x in b.split("."))
    return (ta > tb) - (ta < tb)


# ---------------------------------------------------------------------------
# ConfigManager
# ---------------------------------------------------------------------------

class ConfigManager:
    """Manages config.ini: generation, loading, merging with defaults.

    Config file lives next to the script.  Missing keys are filled from
    DEFAULT_CONFIG; extra keys in the user file are preserved.
    Comments are preserved across updates (regex-based line replacement).

    If an old ``config.yaml`` is detected, it is migrated automatically.
    """

    # Auto-inferred types from DEFAULT_CONFIG values.
    _KEY_TYPES: dict[str, type] = {
        key: type(val)
        for section in DEFAULT_CONFIG.values()
        if isinstance(section, dict)
        for key, val in section.items()
    }

    def __init__(self, script_dir: Path) -> None:
        self._path = script_dir / "config.ini"
        self._yaml_path = script_dir / "config.yaml"

    @property
    def path(self) -> Path:
        """Return the resolved config file path."""
        return self._path

    def load(self) -> dict[str, Any]:
        """Load config from disk or generate a default one.

        Returns:
            Merged configuration dictionary (2-level: section → key → value).

        Raises:
            RedictumError: If config.ini exists but cannot be parsed.
        """
        # Migrate from YAML if needed
        if not self._path.exists() and self._yaml_path.exists():
            self._migrate_yaml()

        if not self._path.exists():
            self._write_default()
            return self._expand_paths(self._deep_copy(DEFAULT_CONFIG))

        import configparser

        cp = configparser.ConfigParser(interpolation=None)
        try:
            cp.read(str(self._path), encoding="utf-8")
        except configparser.Error as exc:
            raise RedictumError(
                f"Invalid INI in {self._path}: {exc}"
            ) from exc

        # Convert configparser sections into a 2-level dict
        user_config: dict[str, Any] = {}
        for section in cp.sections():
            user_config[section] = {}
            for key, raw_value in cp.items(section):
                user_config[section][key] = self._parse_value(key, raw_value)

        merged = self._deep_copy(DEFAULT_CONFIG)
        self._deep_merge(merged, user_config)
        return self._expand_paths(merged)

    def update(self, updates: dict[str, str]) -> None:
        """Update leaf keys in config.ini, preserving comments.

        Performs line-by-line value replacement so that the INI template
        structure and comments remain intact.  Key names must be unique
        across the entire config.

        Args:
            updates: ``{key: value}`` pairs, e.g. ``{"whisper_cli": "/path"}``.
        """
        if self._path.exists():
            text = self._path.read_text(encoding="utf-8")
        else:
            text = DEFAULT_CONFIG_INI

        for key, value in updates.items():
            ini_val = self._format_value(value)
            text = re.sub(
                rf"^({re.escape(key)}\s*=)\s*.*$",
                lambda m, v=ini_val: f"{m.group(1)} {v}",
                text,
                count=1,
                flags=re.MULTILINE,
            )

        self._path.write_text(text, encoding="utf-8")

    # -- migration -----------------------------------------------------------

    def _migrate_yaml(self) -> None:
        """Migrate config.yaml → config.ini, rename yaml to .yaml.bak."""
        try:
            import yaml
        except ImportError:
            # PyYAML not available — can't read old config, skip migration
            return

        try:
            raw = self._yaml_path.read_text(encoding="utf-8")
            data = yaml.safe_load(raw)
        except Exception:
            # Can't parse old config — skip migration, start fresh
            return

        if not isinstance(data, dict):
            return

        # Flatten 3-level YAML → 2-level INI key mapping
        yaml_to_ini: dict[str, tuple[str, str]] = {
            # (yaml path) → (ini_section, ini_key)
        }
        for section, sub in DEFAULT_CONFIG.items():
            if isinstance(sub, dict):
                for ini_key in sub:
                    # Reverse-engineer YAML path from INI key
                    # e.g. "whisper_cli" → ("dependency","whisper","cli")
                    parts = ini_key.split("_", 1)
                    if len(parts) == 2:
                        yaml_to_ini[f"{section}.{parts[0]}.{parts[1]}"] = (section, ini_key)

        # Write INI template, then override with user values
        text = DEFAULT_CONFIG_INI
        updates: dict[str, str] = {}

        for section, sub in data.items():
            if not isinstance(sub, dict):
                continue
            for group, values in sub.items():
                if isinstance(values, dict):
                    for key, value in values.items():
                        path = f"{section}.{group}.{key}"
                        if path in yaml_to_ini:
                            _sec, ini_key = yaml_to_ini[path]
                            updates[ini_key] = value

        for key, value in updates.items():
            ini_val = self._format_value(value)
            text = re.sub(
                rf"^({re.escape(key)}\s*=)\s*.*$",
                lambda m, v=ini_val: f"{m.group(1)} {v}",
                text,
                count=1,
                flags=re.MULTILINE,
            )

        self._path.write_text(text, encoding="utf-8")
        self._yaml_path.rename(self._yaml_path.with_suffix(".yaml.bak"))
        logging.info("Migrated config.yaml → config.ini")

    # -- private helpers -----------------------------------------------------

    def sync(self) -> None:
        """Sync config file on disk with the current template.

        If config.ini exists and is missing keys from DEFAULT_CONFIG,
        regenerate it from DEFAULT_CONFIG_INI and re-apply user values.
        Creates a .bak backup before rewriting.
        """
        if not self._path.exists():
            return

        import configparser

        cp = configparser.ConfigParser(interpolation=None)
        try:
            cp.read(str(self._path), encoding="utf-8")
        except configparser.Error:
            return  # broken config — load() will handle the error

        # Collect all keys present in user's file
        user_keys: set[str] = set()
        for section in cp.sections():
            for key, _value in cp.items(section):
                user_keys.add(key)

        # Collect all keys expected by DEFAULT_CONFIG
        default_keys: set[str] = set()
        for section_data in DEFAULT_CONFIG.values():
            if isinstance(section_data, dict):
                default_keys.update(section_data.keys())

        if default_keys.issubset(user_keys):
            return  # nothing to sync

        missing = default_keys - user_keys
        logging.info("Config sync: adding missing keys: %s", sorted(missing))

        # Collect user values (parsed to Python types, only known keys)
        user_values: dict[str, Any] = {}
        for section in cp.sections():
            for key, raw_value in cp.items(section):
                if key in default_keys:
                    user_values[key] = self._parse_value(key, raw_value)

        # Build new config in memory: fresh template + user values
        text = DEFAULT_CONFIG_INI
        for key, value in user_values.items():
            ini_val = self._format_value(value)
            text = re.sub(
                rf"^({re.escape(key)}\s*=)\s*.*$",
                lambda m, v=ini_val: f"{m.group(1)} {v}",
                text,
                count=1,
                flags=re.MULTILINE,
            )

        # Backup old config
        backup_path = self._path.with_suffix(".ini.bak")
        try:
            shutil.copy2(str(self._path), str(backup_path))
            logging.info("Config backup saved: %s", backup_path)
        except OSError as exc:
            logging.warning("Config sync: backup failed (%s), aborting sync", exc)
            return

        # Atomic write: tempfile + rename
        fd = None
        tmp_path = None
        try:
            fd, tmp_path = tempfile.mkstemp(
                dir=str(self._path.parent), suffix=".tmp",
            )
            os.write(fd, text.encode("utf-8"))
            os.close(fd)
            fd = None
            os.rename(tmp_path, str(self._path))
            tmp_path = None
            logging.info("Config synced: added %s", sorted(missing))
        except OSError as exc:
            logging.warning("Config sync: write failed (%s), aborting", exc)
        finally:
            if fd is not None:
                os.close(fd)
            if tmp_path is not None:
                Path(tmp_path).unlink(missing_ok=True)

    def _write_default(self) -> None:
        """Write DEFAULT_CONFIG_INI template with comments."""
        self._path.write_text(DEFAULT_CONFIG_INI, encoding="utf-8")

    @classmethod
    def _parse_value(cls, key: str, raw: str) -> Any:
        """Parse a raw INI string value into the appropriate Python type."""
        value = cls._strip_quotes(raw)
        expected = cls._KEY_TYPES.get(key, str)
        if expected is bool:
            lower = value.lower()
            if lower in ("true", "yes", "1", "on"):
                return True
            if lower in ("false", "no", "0", "off"):
                return False
            raise RedictumError(
                f"Config '{key}': expected boolean (true/false), got '{value}'"
            )
        if expected is int:
            try:
                return int(value)
            except ValueError as exc:
                raise RedictumError(
                    f"Config '{key}': expected integer, got '{value}'"
                ) from exc
        if expected is float:
            try:
                return float(value)
            except ValueError as exc:
                raise RedictumError(
                    f"Config '{key}': expected number, got '{value}'"
                ) from exc
        return value

    @staticmethod
    def _strip_quotes(value: str) -> str:
        """Strip surrounding double quotes from a string value.

        Paired quotes are removed:  "hello" → hello, "" → empty string.
        Unpaired or escaped quotes are left as-is.
        """
        if len(value) >= 2 and value[0] == '"' and value[-1] == '"':
            if not value.endswith('\\"'):
                return value[1:-1]
        return value

    @staticmethod
    def _format_value(value: Any) -> str:
        """Format a Python value for INI output."""
        if isinstance(value, bool):
            return "true" if value else "false"
        if isinstance(value, str):
            return f'"{value}"'
        return str(value)

    @staticmethod
    def _deep_copy(d: dict[str, Any]) -> dict[str, Any]:
        """Return a deep copy of a nested dict (no import needed)."""
        out: dict[str, Any] = {}
        for k, v in d.items():
            out[k] = ConfigManager._deep_copy(v) if isinstance(v, dict) else v
        return out

    @staticmethod
    def _deep_merge(base: dict[str, Any], override: dict[str, Any]) -> None:
        """Recursively merge *override* into *base* in place."""
        for k, v in override.items():
            if k in base and isinstance(base[k], dict) and isinstance(v, dict):
                ConfigManager._deep_merge(base[k], v)
            else:
                base[k] = v

    @staticmethod
    def _expand_paths(config: dict[str, Any]) -> dict[str, Any]:
        """Expand ``~`` in path-valued keys."""
        for path_keys in PATH_KEYS:
            node: Any = config
            for part in path_keys[:-1]:
                node = node.get(part, {})
            leaf = path_keys[-1]
            if leaf in node and isinstance(node[leaf], str):
                node[leaf] = str(Path(node[leaf]).expanduser())
        return config


# ---------------------------------------------------------------------------
# DirectoryManager
# ---------------------------------------------------------------------------

class DirectoryManager:
    """Creates required working directories next to the script.

    Directories: audio/, transcripts/, logs/.
    """

    def __init__(self, script_dir: Path) -> None:
        self._script_dir = script_dir

    def ensure(self) -> None:
        """Create all required directories if they don't exist."""
        for name in REQUIRED_DIRS:
            (self._script_dir / name).mkdir(exist_ok=True)


class StateManager:
    """Persistent JSON state file for runtime metadata.

    Stores version tracking, build metadata, and UI state between sessions.
    """

    def __init__(self, base_dir: Path) -> None:
        self._path = base_dir / STATE_FILENAME

    @property
    def path(self) -> Path:
        return self._path

    def load(self) -> dict:
        """Load state from disk. Returns {} on missing/corrupt file."""
        import json

        if not self._path.exists():
            return {}
        try:
            data = json.loads(self._path.read_text(encoding="utf-8"))
        except (json.JSONDecodeError, OSError) as exc:
            logging.warning("Corrupt state file %s: %s", self._path, exc)
            return {}
        if not isinstance(data, dict):
            logging.warning("State file %s: expected dict, got %s", self._path, type(data).__name__)
            return {}
        return data

    def save(self, state: dict) -> None:
        """Write state dict to disk as formatted JSON (atomic via rename)."""
        import json
        import tempfile

        data = json.dumps(state, indent=2, ensure_ascii=False) + "\n"
        fd, tmp = tempfile.mkstemp(dir=self._path.parent, suffix=".tmp")
        try:
            os.write(fd, data.encode("utf-8"))
            os.close(fd)
            os.rename(tmp, str(self._path))
        except BaseException:
            try:
                os.close(fd)
            except OSError:
                pass
            Path(tmp).unlink(missing_ok=True)
            raise

    def get(self, key: str, default: Any = None) -> Any:
        """Load state and return a single key."""
        return self.load().get(key, default)

    def set(self, key: str, value: Any) -> None:
        """Load state, set a single key, and save."""
        state = self.load()
        state[key] = value
        self.save(state)


# ---------------------------------------------------------------------------
# Stubs
# ---------------------------------------------------------------------------


@dataclass(frozen=True)
class _OptionalDep:
    """Descriptor for an optional dependency checked during setup."""

    tool: str                       # binary name (shutil.which)
    package: str                    # apt package name
    label: str                      # human-readable feature name
    section: str                    # config section name
    guard_keys: tuple[str, ...]     # keys for config-guard check
    enable_keys: dict[str, bool]    # keys to set on force-enable
    disable_keys: dict[str, bool]   # keys to set on disable


_OPTIONAL_DEPS: list[_OptionalDep] = [
    _OptionalDep(
        "paplay", "pulseaudio-utils", "Sound notifications", "notification",
        ("sound_signal_start", "sound_signal_processing",
         "sound_signal_done", "sound_signal_error"),
        {"sound_signal_start": True, "sound_signal_done": True,
         "sound_signal_error": True},
        {"sound_signal_start": False, "sound_signal_processing": False,
         "sound_signal_done": False, "sound_signal_error": False},
    ),
    _OptionalDep(
        "ffmpeg", "ffmpeg", "Audio normalization", "audio",
        ("recording_normalize",),
        {"recording_normalize": True},
        {"recording_normalize": False},
    ),
    _OptionalDep(
        "xdotool", "xdotool", "Auto-paste", "clipboard",
        ("paste_auto",),
        {"paste_auto": True},
        {"paste_auto": False},
    ),
]


class Diagnostics:
    """Check external dependencies and offer auto-installation.

    Stage 1 — critical checks (fail fast): Python 3.10+, Linux, ALSA, X11.
    If any fail, raise RedictumError.

    Stage 2 — installable dependencies (auto-fix): apt and pip packages.
    Offer to install missing ones, user confirms with y/n.

    Optional — paplay, ffmpeg, xdotool: if missing, offer to install or
    disable the corresponding feature in config.

    whisper.cpp — offer auto-install if missing (clone, build, model download).
    """

    def __init__(self, config: dict[str, Any], config_mgr: ConfigManager,
                 state_mgr: StateManager | None = None) -> None:
        self._config = config
        self._config_mgr = config_mgr
        self._state_mgr = state_mgr

    # -- Stage 1: critical checks -------------------------------------------

    def run_stage1(self) -> None:
        """Run all critical checks. Raise RedictumError on first failure."""
        _rprint("[bold]Checking dependencies...[/bold]")
        self._check_python()
        self._check_linux()
        self._check_alsa()
        self._detect_audio_device()
        self._check_x11()

    def _check_python(self) -> None:
        ver = sys.version_info
        label = f"Python {ver.major}.{ver.minor}.{ver.micro}"
        if ver >= (3, 10):
            _rprint(f"  [green]\u2713[/green] {label}")
            logging.info("Check: %s — OK", label)
        else:
            _rprint(f"  [red]\u2717[/red] {label}")
            logging.error("Check: %s — FAIL (need 3.10+)", label)
            raise RedictumError(
                f"Python 3.10+ is required, found {label}."
            )

    def _check_linux(self) -> None:
        if sys.platform == "linux":
            _rprint("  [green]\u2713[/green] Linux")
            logging.info("Check: Linux — OK")
        else:
            _rprint(f"  [red]\u2717[/red] Linux — detected {sys.platform}")
            logging.error("Check: Linux — FAIL (detected %s)", sys.platform)
            raise RedictumError(
                f"Linux is required, detected platform: {sys.platform}."
            )

    def _check_alsa(self) -> None:
        if shutil.which("arecord"):
            _rprint("  [green]\u2713[/green] ALSA (arecord)")
            logging.info("Check: ALSA — OK")
        else:
            _rprint("  [red]\u2717[/red] ALSA (arecord) \u2014 not found")
            logging.error("Check: ALSA — MISSING")
            raise RedictumError(
                "ALSA (arecord) is required but not found.\n"
                "Install it manually: sudo apt install alsa-utils"
            )

    def _detect_audio_device(self) -> None:
        """Auto-detect a working ALSA recording device if config says 'auto'."""
        device = self._config.get("audio", {}).get("recording_device", "auto")
        if device != "auto":
            _rprint(f"  [green]\u2713[/green] Audio device: {device} (manual)")
            logging.info("Check: Audio device: %s (manual)", device)
            return

        candidates = ["pulse", "default"]
        for candidate in candidates:
            if self._test_audio_device(candidate):
                _rprint(f"  [green]\u2713[/green] Audio device: {candidate} (auto-detected)")
                logging.info("Check: Audio device: %s (auto)", candidate)
                self._config_mgr.update({"recording_device": candidate})
                self._config["audio"]["recording_device"] = candidate
                return

        _rprint("  [red]\u2717[/red] Audio device \u2014 no working device found")
        logging.error("Check: Audio device — no working device found")
        raise RedictumError(
            "No working audio recording device found.\n"
            "Tried: " + ", ".join(candidates) + "\n"
            "Check: arecord -l (ALSA devices), pactl info (PulseAudio)\n"
            "Config: [audio] recording_device in config.ini"
        )

    @staticmethod
    def _test_audio_device(device: str) -> bool:
        """Test if arecord can open the given device (1-second recording)."""
        import tempfile
        fd, path = tempfile.mkstemp(suffix=".wav")
        os.close(fd)
        try:
            result = subprocess.run(
                [
                    "arecord", "-D", device,
                    "-f", "S16_LE", "-r", "16000", "-c", "1",
                    "-d", "1", "-t", "wav", path,
                ],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                timeout=5,
            )
            return result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError, OSError):
            return False
        finally:
            Path(path).unlink(missing_ok=True)

    def _check_x11(self) -> None:
        display = os.environ.get("DISPLAY")
        if display:
            _rprint("  [green]\u2713[/green] X11 (DISPLAY)")
            logging.info("Check: X11 DISPLAY=%s — OK", display)
        else:
            _rprint("  [red]\u2717[/red] X11 (DISPLAY) \u2014 not set")
            logging.error("Check: X11 DISPLAY — not set")
            raise RedictumError(
                "X11 display is required but DISPLAY is not set.\n"
                "Run from an X11 session or set DISPLAY manually."
            )

    # -- Stage 2: installable dependencies ----------------------------------

    def run_stage2(self) -> None:
        """Find missing installable deps and offer to install them."""
        missing_apt = self._find_missing_apt()
        missing_pip = self._find_missing_pip()

        if not missing_apt and not missing_pip:
            return

        # Print summary of missing packages
        if missing_apt:
            _rprint(f"\nMissing system packages: {', '.join(missing_apt)}")
        if missing_pip:
            _rprint(f"Missing Python packages: {', '.join(missing_pip)}")

        if not _confirm("\nInstall missing dependencies?", default=True):
            _rprint("[yellow]Skipping installation. Some features may not work.[/yellow]")
            return

        ok = True
        if missing_apt:
            if self._has_apt():
                if not self._install_apt(missing_apt):
                    ok = False
            else:
                _rprint(
                    "[yellow]apt not found. Install manually:[/yellow]\n  "
                    + " ".join(missing_apt)
                )
                ok = False
        if missing_pip:
            if not self._install_pip(missing_pip):
                ok = False

        if ok:
            _rprint("[green]All dependencies installed.[/green]")
        else:
            _rprint("[yellow]Some dependencies failed to install.[/yellow]")

    def _find_missing_apt(self) -> list[str]:
        """Return list of missing apt package names."""
        missing: list[str] = []
        for name, package in APT_PACKAGES.items():
            if shutil.which(name) is not None:
                _rprint(f"  [green]\u2713[/green] {name}")
            else:
                _rprint(f"  [red]\u2717[/red] {name}")
                missing.append(package)
        if missing:
            logging.info("Missing apt: %s", missing)
        else:
            logging.info("All apt packages present")
        return missing

    def _find_missing_pip(self) -> list[str]:
        """Return list of missing pip package names."""
        missing: list[str] = []
        for import_name, pip_name in PIP_PACKAGES.items():
            try:
                __import__(import_name)
                _rprint(f"  [green]\u2713[/green] {pip_name}")
            except ImportError:
                _rprint(f"  [red]\u2717[/red] {pip_name}")
                missing.append(pip_name)
        if missing:
            logging.info("Missing pip: %s", missing)
        else:
            logging.info("All pip packages present")
        return missing

    def _install_apt(self, packages: list[str]) -> bool:
        """Run sudo apt install for the given packages. Return success."""
        for pkg in packages:
            if not pkg or len(pkg) < 2 or not re.match(r'^[a-z0-9][a-z0-9+.-]+$', pkg):
                logging.error("Invalid apt package name: %s", pkg)
                return False
        cmd = ["sudo", "apt", "install", "-y", *packages]
        _rprint(f"[dim]Running: {' '.join(cmd)}[/dim]")
        logging.info("Running: %s", " ".join(cmd))
        result = subprocess.run(cmd)
        logging.info("apt install — exit code %d", result.returncode)
        return result.returncode == 0

    def _install_pip(self, packages: list[str]) -> bool:
        """Install Python packages with PEP 668 fallback chain.

        Strategy:
        1. Try ``pip install`` (works on older systems and in containers).
        2. If blocked by PEP 668, try ``apt install python3-*`` equivalents.
        3. If apt unavailable/failed, try ``pip install --break-system-packages``.
        4. If everything fails, print manual instructions.
        """
        # 1. Try normal pip install
        cmd = [sys.executable, "-m", "pip", "install", *packages]
        _rprint(f"[dim]Running: {' '.join(cmd)}[/dim]")
        logging.info("Running: %s", " ".join(cmd))
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            logging.info("pip install — exit code 0")
            return True

        # Check if this is PEP 668 block
        if "externally-managed" not in result.stderr.lower():
            # Some other error — show it
            if result.stderr:
                _rprint(f"[red]{result.stderr.strip()}[/red]")
                logging.warning("pip install failed: %s", result.stderr.strip())
            return False

        _rprint("[yellow]System Python is externally managed (PEP 668).[/yellow]")

        # 2. Try apt equivalents
        apt_packages = [
            PIP_APT_FALLBACK[p]
            for p in packages
            if p in PIP_APT_FALLBACK
        ]
        if apt_packages and self._has_apt():
            logging.info("PEP 668: trying apt fallback")
            _rprint(f"[dim]Trying apt: {' '.join(apt_packages)}[/dim]")
            if self._install_apt(apt_packages):
                return True

        # 3. Try pip with --break-system-packages
        logging.info("PEP 668: trying --break-system-packages")
        cmd = [
            sys.executable, "-m", "pip", "install",
            "--break-system-packages", *packages,
        ]
        _rprint(f"[dim]Running: {' '.join(cmd)}[/dim]")
        logging.info("Running: %s", " ".join(cmd))
        result = subprocess.run(cmd)
        if result.returncode == 0:
            logging.info("pip install — exit code 0")
            return True
        logging.warning("pip install --break-system-packages — exit code %d", result.returncode)

        # 4. All failed — manual instructions
        _rprint(
            "[red]Could not install Python packages automatically.[/red]\n"
            "Try one of:\n"
            f"  sudo apt install {' '.join(apt_packages)}\n"
            f"  pip install --user {' '.join(packages)}\n"
            f"  pip install --break-system-packages {' '.join(packages)}"
        )
        return False

    def _has_apt(self) -> bool:
        """Check if apt is available (Debian/Ubuntu/Mint)."""
        return shutil.which("apt") is not None

    def _check_dpkg(self, package: str) -> bool:
        """Check if a package is installed via dpkg -s."""
        try:
            result = subprocess.run(
                ["dpkg", "-s", package],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            return result.returncode == 0
        except FileNotFoundError:
            return False

    # -- Optional dependencies -----------------------------------------------

    def run_optional(self, force: bool = False) -> None:
        """Check optional dependencies and offer to install or disable.

        Args:
            force: When True, bypass config-guards and check all features
                   (used by ``./redictum setup``).  On successful install,
                   re-enable the feature in config.
        """
        _rprint("\n[bold]Optional features:[/bold]")
        for dep in _OPTIONAL_DEPS:
            self._check_optional_dep(dep, force=force)

    def _apply_dep_config(self, section: str, keys: dict[str, bool]) -> None:
        """Update config file and in-memory config for a dependency."""
        self._config_mgr.update({k: str(v).lower() for k, v in keys.items()})
        for key, value in keys.items():
            self._config.setdefault(section, {})[key] = value

    def _check_optional_dep(self, dep: _OptionalDep, force: bool = False) -> None:
        """Check a single optional dependency, offer install or disable."""
        # Config-guard: skip if all guard keys already disabled
        if not force:
            sect = self._config.get(dep.section, {})
            if not any(sect.get(k, True) for k in dep.guard_keys):
                _rprint(f"  [dim]-[/dim] {dep.label} (disabled"
                        " \u2014 run './redictum setup' to reconfigure)")
                logging.info("Optional: %s — skipped (disabled in config)", dep.tool)
                return
        if shutil.which(dep.tool):
            _rprint(f"  [green]\u2713[/green] {dep.label} ({dep.tool})")
            logging.info("Optional: %s — found", dep.tool)
            if force:
                self._apply_dep_config(dep.section, dep.enable_keys)
            return
        _rprint(f"  [yellow]\u26a0[/yellow] {dep.tool} not found"
                f" — {dep.label.lower()} unavailable")
        logging.info("Optional: %s — missing", dep.tool)
        pkg_hint = (f"{dep.package} ({dep.tool})" if dep.package != dep.tool
                    else dep.package)
        if _confirm(f"Install {pkg_hint} for {dep.label.lower()}?",
                    default=True):
            if self._has_apt() and self._install_apt([dep.package]):
                _rprint(f"  [green]\u2713[/green] {dep.tool} installed")
                logging.info("Optional: %s — installed", dep.tool)
                if force:
                    self._apply_dep_config(dep.section, dep.enable_keys)
                return
            _rprint("  [yellow]Installation failed.[/yellow]")
        self._apply_dep_config(dep.section, dep.disable_keys)
        _rprint(f"  [dim]{dep.label} disabled in config[/dim]")
        logging.info("Optional: %s disabled in config", dep.tool)

    # -- whisper.cpp: warning only ------------------------------------------

    def check_whisper(self) -> None:
        """Check whisper.cpp and model, offer installation if missing."""
        whisper = self._config.get("dependency", {})
        cli_path = whisper.get("whisper_cli", "")
        model_path = whisper.get("whisper_model", "")
        cli_ok = bool(cli_path) and Path(cli_path).exists()
        model_ok = bool(model_path) and Path(model_path).exists()

        if cli_ok:
            _rprint("  [green]\u2713[/green] whisper.cpp")
        else:
            _rprint(f"  [yellow]\u26a0[/yellow] whisper.cpp not found at {cli_path}")
        logging.info("Whisper CLI: %s — %s", cli_path, "found" if cli_ok else "missing")

        if model_ok:
            _rprint("  [green]\u2713[/green] whisper model")
        else:
            _rprint(f"  [yellow]\u26a0[/yellow] whisper model not found at {model_path}")
        logging.info("Whisper model: %s — %s", model_path, "found" if model_ok else "missing")

        if cli_ok and model_ok:
            return

        if cli_ok and not model_ok:
            prompt = "\nDownload whisper model?"
        else:
            prompt = "\nInstall whisper.cpp?"

        if _confirm(prompt, default=True):
            installer = WhisperInstaller(self._config_mgr, self._state_mgr)
            installer.install()
        else:
            _rprint(
                "[yellow]Skipping. You can install later with:[/yellow] "
                "[bold]./redictum whisper[/bold]"
            )


class WhisperInstaller:  # pragma: no cover
    """Setup wizard for whisper.cpp: install, configure, reconfigure."""

    WHISPER_VERSION = "v1.8.3"
    TARBALL_URL = "https://github.com/ggerganov/whisper.cpp/archive/refs/tags/{version}.tar.gz"
    HF_BASE = "https://huggingface.co/ggerganov/whisper.cpp/resolve/main"

    MODELS: list[tuple[str, str, str]] = [
        ("large-v3-turbo-q5_0", "ggml-large-v3-turbo-q5_0.bin", "~547 MB, best speed/quality"),
        ("large-v3-turbo", "ggml-large-v3-turbo.bin", "~1.6 GB, full turbo"),
        ("large-v3", "ggml-large-v3.bin", "~3.1 GB, highest quality"),
        ("medium", "ggml-medium.bin", "~1.5 GB"),
        ("small", "ggml-small.bin", "~466 MB"),
        ("base", "ggml-base.bin", "~142 MB"),
        ("tiny", "ggml-tiny.bin", "~75 MB, fastest"),
    ]

    def __init__(self, config_mgr: ConfigManager,
                 state_mgr: StateManager | None = None) -> None:
        self._config_mgr = config_mgr
        self._state_mgr = state_mgr
        self._install_dir = Path.home() / "whisper.cpp"

    def _record_build_type(self, cuda: bool) -> None:
        """Save whisper build type (cuda/cpu) to state."""
        if self._state_mgr is not None:
            self._state_mgr.set("whisper_build", "cuda" if cuda else "cpu")

    # -- Public API ----------------------------------------------------------

    def install(self) -> None:
        """Smart setup: detect state, install/reconfigure as needed."""
        _rprint("\n[bold]whisper.cpp Setup[/bold]")

        cli_path = self._install_dir / "build" / "bin" / "whisper-cli"

        if cli_path.exists():
            self._reconfigure(cli_path)
        else:
            self._fresh_install()

    # -- Flows ---------------------------------------------------------------

    def _fresh_install(self) -> None:
        """Full install: ensure CUDA, download, build, download model."""
        logging.info("Whisper: fresh install")
        cuda_available = self._ensure_cuda()
        logging.info("Whisper: CUDA available=%s", cuda_available)
        self._clone()
        self._build(use_cuda=cuda_available)

        cli_path = self._install_dir / "build" / "bin" / "whisper-cli"
        if not cli_path.exists():
            raise RedictumError(
                f"Build completed but whisper-cli not found at {cli_path}"
            )

        model_path = self._select_and_download()
        self._update_config(cli_path, model_path)
        self._record_build_type(cuda_available)
        _rprint("\n[green]whisper.cpp setup complete![/green]")

    def _reconfigure(self, cli_path: Path) -> None:
        """Re-check existing install, offer improvements."""
        cuda_linked = self._is_cuda_linked(cli_path)

        if cuda_linked:
            _rprint("  [green]\u2713[/green] whisper.cpp [bold](CUDA)[/bold]")
        else:
            _rprint("  [green]\u2713[/green] whisper.cpp [dim](CPU-only)[/dim]")

        # Offer CUDA rebuild if beneficial
        need_rebuild = False
        rebuild_cuda = False
        if not cuda_linked:
            cuda_ok = self._ensure_cuda()
            if cuda_ok:
                _rprint("  [yellow]\u26a0[/yellow] CUDA ready but whisper.cpp built without it")
                if _confirm("  Rebuild with CUDA for GPU acceleration?", default=True):
                    need_rebuild = True
                    rebuild_cuda = True

        # General rebuild option
        if not need_rebuild:
            if _confirm("  Rebuild whisper.cpp?", default=False):
                need_rebuild = True
                cuda_ok = self._ensure_cuda()
                if cuda_ok:
                    rebuild_cuda = _confirm(
                        "  Build with CUDA?", default=cuda_linked,
                    )

        if need_rebuild:
            self._clone()
            self._build(use_cuda=rebuild_cuda)
            cli_path = self._install_dir / "build" / "bin" / "whisper-cli"
            cuda_linked = rebuild_cuda

        model_path = self._ensure_model()

        # Verify GPU is actually used, not just linked
        if cuda_linked:
            _rprint("  Verifying GPU backend...")
            backend = self._probe_gpu_backend(cli_path, model_path)
            if backend == "cuda":
                _rprint("  [green]\u2713[/green] GPU acceleration [bold]active[/bold]")
            elif backend in ("metal", "vulkan"):
                _rprint(f"  [green]\u2713[/green] GPU acceleration [bold]active[/bold] ({backend})")
            else:
                _rprint(
                    "  [yellow]\u26a0[/yellow] CUDA linked but GPU not active "
                    "\u2014 transcription will use CPU"
                )
                logging.warning(
                    "CUDA linked but GPU backend not detected in probe"
                )

        self._update_config(cli_path, model_path)

        if need_rebuild:
            self._record_build_type(cuda=rebuild_cuda)
            _rprint("\n[green]whisper.cpp reconfigured![/green]")
        else:
            self._record_build_type(cuda=cuda_linked)

    # -- CUDA ----------------------------------------------------------------

    CUDA_MIN_VERSION = 12
    CUDA_KEYRING_URL = (
        "https://developer.download.nvidia.com/compute/cuda/repos"
        "/{distro}/x86_64/cuda-keyring_1.1-1_all.deb"
    )

    def _is_cuda_available(self) -> bool:
        """Check if a modern enough nvcc is available."""
        ver = self._get_nvcc_version()
        return ver is not None and ver >= self.CUDA_MIN_VERSION

    def _is_cuda_linked(self, cli_path: Path) -> bool:
        """Check if the binary links against CUDA libraries."""
        try:
            result = subprocess.run(
                ["ldd", str(cli_path)],
                capture_output=True, text=True, timeout=10,
            )
            output = result.stdout.lower()
            return "cuda" in output or "cublas" in output
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return False

    def _probe_gpu_backend(self, cli_path: Path, model_path: Path) -> str:
        """Run a tiny transcription and detect actual GPU backend from stderr.

        Returns:
            Detected backend: ``"cuda"``, ``"metal"``, ``"vulkan"``, or ``"cpu"``.
        """
        probe_wav = self._make_probe_wav()
        try:
            result = subprocess.run(
                [str(cli_path), "-m", str(model_path), "-f", str(probe_wav),
                 "--no-timestamps"],
                capture_output=True, text=True, timeout=30,
            )
            stderr = result.stderr.lower()
            logging.info("GPU probe stderr:\n%s", result.stderr)
            if "ggml_cuda_init" in stderr and "found" in stderr:
                return "cuda"
            if "ggml_metal_init" in stderr:
                return "metal"
            if "vulkan" in stderr:
                return "vulkan"
            return "cpu"
        except (subprocess.TimeoutExpired, FileNotFoundError, OSError) as exc:
            logging.warning("GPU probe failed: %s", exc)
            return "cpu"
        finally:
            probe_wav.unlink(missing_ok=True)

    @staticmethod
    def _make_probe_wav() -> Path:
        """Generate a minimal 0.5-second silent WAV for GPU probing."""
        sr = 16000
        n = sr // 2
        pcm = b"\x00\x00" * n
        header = struct.pack(
            "<4sI4s4sIHHIIHH4sI",
            b"RIFF", 36 + len(pcm), b"WAVE",
            b"fmt ", 16, 1, 1, sr, sr * 2, 2, 16,
            b"data", len(pcm),
        )
        fd, tmp = tempfile.mkstemp(suffix=".wav", prefix="redictum_probe_")
        try:
            os.write(fd, header + pcm)
            os.close(fd)
        except BaseException:
            try:
                os.close(fd)
            except OSError:
                pass
            Path(tmp).unlink(missing_ok=True)
            raise
        return Path(tmp)

    def _get_nvcc_version(self) -> int | None:
        """Return major CUDA version from nvcc, or None."""
        nvcc = self._find_nvcc()
        if not nvcc:
            return None
        try:
            result = subprocess.run(
                [nvcc, "--version"],
                capture_output=True, text=True, timeout=10,
            )
            # Parse "release 12.8, V12.8.61"
            m = re.search(r"release (\d+)\.", result.stdout)
            return int(m.group(1)) if m else None
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return None

    def _find_nvcc(self) -> str | None:
        """Find nvcc, preferring newest /usr/local/cuda-* over PATH."""
        # Check /usr/local/cuda-* first (NVIDIA repo installs here)
        for cuda_dir in sorted(Path("/usr/local").glob("cuda-*"), reverse=True):
            candidate = cuda_dir / "bin" / "nvcc"
            if candidate.exists():
                return str(candidate)
        # Fall back to PATH (may be old distro package)
        return shutil.which("nvcc")

    def _ensure_cuda(self) -> bool:
        """Check CUDA availability, offer to install/upgrade if needed."""
        nvcc_ver = self._get_nvcc_version()
        if nvcc_ver is not None and nvcc_ver >= self.CUDA_MIN_VERSION:
            _rprint(f"  [green]\u2713[/green] CUDA toolkit {nvcc_ver}")
            return True

        if not shutil.which("nvidia-smi"):
            _rprint("  [dim]No NVIDIA GPU detected, building CPU-only[/dim]")
            return False

        if nvcc_ver is not None:
            _rprint(
                f"  [yellow]\u26a0[/yellow] CUDA toolkit {nvcc_ver} is too old "
                f"(need {self.CUDA_MIN_VERSION}+)"
            )
        else:
            _rprint("  [yellow]\u26a0[/yellow] NVIDIA GPU detected but CUDA toolkit not installed")

        if _confirm("  Install CUDA toolkit from NVIDIA repository?", default=True):
            if self._install_cuda_toolkit():
                return True
        _rprint("  [dim]Continuing with CPU-only build[/dim]")
        return False

    def _detect_ubuntu_distro(self) -> str | None:
        """Detect Ubuntu base for NVIDIA repo (e.g. 'ubuntu2204')."""
        try:
            text = Path("/etc/os-release").read_text()
        except FileNotFoundError:
            return None
        # Mint, Pop!_OS etc. have UBUNTU_CODENAME
        m = re.search(r'UBUNTU_CODENAME=(\w+)', text)
        if not m:
            m = re.search(r'VERSION_CODENAME=(\w+)', text)
        if not m:
            return None
        codename = m.group(1)
        codename_map: dict[str, str] = {
            "focal": "ubuntu2004",
            "jammy": "ubuntu2204",
            "noble": "ubuntu2404",
        }
        return codename_map.get(codename)

    def _install_cuda_toolkit(self) -> bool:
        """Install CUDA toolkit from NVIDIA apt repository."""
        distro = self._detect_ubuntu_distro()
        if not distro:
            _rprint(
                "  [yellow]\u26a0[/yellow] Could not detect Ubuntu version. "
                "Install CUDA toolkit manually:\n"
                "    https://developer.nvidia.com/cuda-downloads"
            )
            logging.warning("CUDA: cannot detect Ubuntu version")
            return False

        logging.info("CUDA: detected base %s", distro)
        _rprint(f"  Detected base: {distro}")

        # Download and install keyring
        keyring_url = self.CUDA_KEYRING_URL.format(distro=distro)
        fd, keyring_path = tempfile.mkstemp(suffix=".deb", prefix="cuda-keyring-")
        keyring_deb = Path(keyring_path)
        os.close(fd)

        try:
            _rprint("  [dim]Downloading NVIDIA CUDA keyring...[/dim]")
            dl_cmd: list[str] = []
            if shutil.which("curl"):
                dl_cmd = ["curl", "-fsSL", "-o", str(keyring_deb), keyring_url]
            elif shutil.which("wget"):
                dl_cmd = ["wget", "-q", "-O", str(keyring_deb), keyring_url]
            else:
                _rprint("  [red]Neither curl nor wget found[/red]")
                return False

            logging.info("CUDA: downloading keyring")
            if subprocess.run(dl_cmd).returncode != 0:
                _rprint("  [yellow]\u26a0[/yellow] Failed to download CUDA keyring")
                logging.warning("CUDA: keyring download failed")
                return False

            _rprint("  [dim]Installing CUDA keyring and toolkit (sudo required)...[/dim]")
            logging.info("CUDA: installing keyring (dpkg)")
            result = subprocess.run(["sudo", "dpkg", "-i", str(keyring_deb)])
            if result.returncode != 0:
                _rprint("  [yellow]\u26a0[/yellow] Failed to install CUDA keyring")
                logging.warning("CUDA: dpkg keyring — exit code %d", result.returncode)
                return False

            logging.info("CUDA: apt-get update")
            result = subprocess.run(["sudo", "apt-get", "update", "-qq"])
            if result.returncode != 0:
                _rprint("  [yellow]\u26a0[/yellow] Failed to update package list")
                logging.warning("CUDA: apt-get update — exit code %d", result.returncode)
                return False

            logging.info("CUDA: apt-get install cuda-toolkit")
            result = subprocess.run(
                ["sudo", "apt-get", "install", "-y", "cuda-toolkit"],
            )
            if result.returncode != 0:
                _rprint("  [yellow]\u26a0[/yellow] CUDA toolkit installation failed")
                logging.warning("CUDA: apt install — exit code %d", result.returncode)
                return False

            # Verify new nvcc
            ver = self._get_nvcc_version()
            if ver and ver >= self.CUDA_MIN_VERSION:
                _rprint(f"  [green]\u2713[/green] CUDA toolkit {ver} installed")
                logging.info("CUDA: toolkit %d installed successfully", ver)
                return True

            _rprint("  [yellow]\u26a0[/yellow] CUDA installed but nvcc not found in PATH")
            logging.warning("CUDA: installed but nvcc not found in PATH")
            return False
        finally:
            keyring_deb.unlink(missing_ok=True)

    # -- Clone / Build -------------------------------------------------------

    def _clone(self) -> None:
        """Download and extract the whisper.cpp release tarball."""
        logging.info("Whisper: cloning repo %s", self.WHISPER_VERSION)
        url = self.TARBALL_URL.format(version=self.WHISPER_VERSION)
        fd, tarball_path = tempfile.mkstemp(suffix=".tar.gz", prefix="whisper-cpp-")
        tarball = Path(tarball_path)
        os.close(fd)

        # Preserve models directory across re-clone (same filesystem = instant)
        models_dir = self._install_dir / "models"
        saved_models = self._install_dir.parent / ".whisper_models_backup"
        models_saved = False

        try:
            # Save models or pick up leftover backup from a previous failed run
            if models_dir.is_dir() and any(models_dir.iterdir()):
                if saved_models.exists():
                    shutil.rmtree(saved_models)
                models_dir.rename(saved_models)
                models_saved = True
                logging.info("Whisper: models preserved (%d files)",
                             len(list(saved_models.iterdir())))
            elif saved_models.is_dir() and any(saved_models.iterdir()):
                models_saved = True
                logging.info("Whisper: recovered leftover model backup")

            if self._install_dir.exists():
                _rprint(f"  Removing old {self._install_dir}...")
                shutil.rmtree(self._install_dir)

            _rprint(f"  Downloading whisper.cpp {self.WHISPER_VERSION}...")
            if shutil.which("curl"):
                cmd = ["curl", "-fsSL", "-o", str(tarball), url]
            elif shutil.which("wget"):
                cmd = ["wget", "-q", "-O", str(tarball), url]
            else:
                raise RedictumError("Neither curl nor wget found")

            result = subprocess.run(cmd)
            if result.returncode != 0:
                raise RedictumError("Failed to download whisper.cpp tarball")

            _rprint("  Extracting...")
            result = subprocess.run(
                ["tar", "xzf", str(tarball), "-C", str(self._install_dir.parent)],
            )
            if result.returncode != 0:
                raise RedictumError("Failed to extract whisper.cpp tarball")

            # tar extracts to whisper.cpp-<version> (without 'v' prefix)
            version_stripped = self.WHISPER_VERSION.lstrip("v")
            extracted = self._install_dir.parent / f"whisper.cpp-{version_stripped}"
            if extracted.exists():
                extracted.rename(self._install_dir)
            elif not self._install_dir.exists():
                raise RedictumError(
                    f"Expected directory {extracted} not found after extraction"
                )

            # Restore models
            if models_saved and saved_models.exists():
                target = self._install_dir / "models"
                if target.exists():
                    shutil.rmtree(target)
                saved_models.rename(target)
                _rprint("  [green]\u2713[/green] Models preserved")
                logging.info("Whisper: models restored")
                models_saved = False

            _rprint(f"  [green]\u2713[/green] whisper.cpp {self.WHISPER_VERSION} ready")
        finally:
            tarball.unlink(missing_ok=True)

    def _ensure_build_tools(self) -> None:
        """Check cmake and build-essential; offer to install if missing."""
        missing: list[str] = []
        if not shutil.which("cmake"):
            missing.append("cmake")
        try:
            result = subprocess.run(
                ["dpkg", "-s", "build-essential"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            if result.returncode != 0:
                missing.append("build-essential")
        except FileNotFoundError:
            missing.append("build-essential")
        if not missing:
            return
        _rprint(f"  [yellow]\u26a0[/yellow] Build tools missing: {', '.join(missing)}")
        logging.info("Build tools missing: %s", missing)
        if not _confirm("Install build tools (cmake, build-essential)?", default=True):
            raise RedictumError(
                "Build tools required for whisper.cpp compilation.\n"
                f"Install manually: sudo apt install {' '.join(missing)}"
            )
        cmd = ["sudo", "apt", "install", "-y", *missing]
        _rprint(f"[dim]Running: {' '.join(cmd)}[/dim]")
        logging.info("Running: %s", " ".join(cmd))
        result = subprocess.run(cmd)
        if result.returncode != 0:
            raise RedictumError("Failed to install build tools")
        _rprint("  [green]\u2713[/green] Build tools installed")
        logging.info("Build tools installed")

    def _build(self, use_cuda: bool) -> None:
        """Configure and build whisper.cpp."""
        self._ensure_build_tools()
        logging.info("Whisper: build started (CUDA=%s)", use_cuda)
        # Clean previous build
        build_dir = self._install_dir / "build"
        if build_dir.exists():
            shutil.rmtree(build_dir)

        mode = "CUDA" if use_cuda else "CPU"
        _rprint(f"  Configuring build ({mode})...")
        cmake_args = [
            "cmake", "-B", "build",
            "-DCMAKE_BUILD_TYPE=Release",
        ]
        if use_cuda:
            cmake_args.append("-DGGML_CUDA=ON")
            nvcc = self._find_nvcc()
            if nvcc and nvcc != shutil.which("nvcc"):
                cmake_args.append(f"-DCMAKE_CUDA_COMPILER={nvcc}")

        result = subprocess.run(
            cmake_args,
            cwd=str(self._install_dir),
            capture_output=True, text=True,
        )
        if result.returncode != 0:
            if use_cuda:
                _rprint("  [yellow]\u26a0[/yellow] CUDA configure failed:")
                for line in result.stderr.strip().split("\n")[-3:]:
                    _rprint(f"    [dim]{line}[/dim]")
                _rprint("  Retrying with CPU-only...")
                self._build(use_cuda=False)
                return
            logging.error("cmake configure stderr:\n%s", result.stderr)
            logging.error("cmake configure stdout:\n%s", result.stdout)
            raise RedictumError(
                f"cmake configure failed:\n{result.stderr.strip()[-500:]}"
            )
        _rprint(f"  [green]\u2713[/green] Configured ({mode})")

        jobs = os.cpu_count() or 1
        if use_cuda:
            _rprint(f"  Building ({mode}, {jobs} jobs)...")
            _rprint("  [yellow]CUDA build takes 10-15 min. Do not interrupt![/yellow]")
        else:
            _rprint(f"  Building ({mode}, {jobs} jobs, may take several minutes)...")
        result = subprocess.run(
            ["cmake", "--build", "build", "--config", "Release",
             "-j", str(jobs)],
            cwd=str(self._install_dir),
            capture_output=True, text=True,
        )
        if result.returncode != 0:
            if use_cuda:
                err = result.stderr or result.stdout or ""
                _rprint("  [yellow]\u26a0[/yellow] CUDA build failed:")
                for line in err.strip().split("\n")[-5:]:
                    _rprint(f"    [dim]{line}[/dim]")
                _rprint("  Retrying with CPU-only...")
                self._build(use_cuda=False)
                return
            raise RedictumError("cmake build failed")
        _rprint(f"  [green]\u2713[/green] Build complete ({mode})")
        logging.info("Whisper: build complete — exit code %d", result.returncode)

    # -- Model ---------------------------------------------------------------

    def _select_and_download(self) -> Path:
        """Let the user pick a model and download it."""
        if _verbosity < 0:
            # Quiet mode: pick recommended (first) model
            _name, filename, _desc = self.MODELS[0]
            return self._download_model(filename)

        _rprint("\n  [bold]Available models:[/bold]")
        for i, (name, _filename, desc) in enumerate(self.MODELS, 1):
            marker = " [bold](recommended)[/bold]" if i == 1 else ""
            _rprint(f"    {i}. {name} — {desc}{marker}")

        while True:
            try:
                choice = input(
                    f"\n  Select model [1-{len(self.MODELS)}, default=1]: "
                ).strip()
            except (EOFError, KeyboardInterrupt):
                print()
                choice = ""
            if not choice:
                choice = "1"
            try:
                idx = int(choice) - 1
                if 0 <= idx < len(self.MODELS):
                    break
            except ValueError:
                pass
            _rprint(f"  [red]Invalid choice, enter 1-{len(self.MODELS)}[/red]")

        _name, filename, _desc = self.MODELS[idx]
        return self._download_model(filename)

    def _download_model(self, filename: str) -> Path:
        """Download a model file from Hugging Face."""
        models_dir = self._install_dir / "models"
        models_dir.mkdir(exist_ok=True)
        model_path = models_dir / filename

        if model_path.exists():
            _rprint(f"  [green]\u2713[/green] Model already downloaded: {filename}")
            return model_path

        url = f"{self.HF_BASE}/{filename}"
        logging.info("Whisper: downloading model %s", filename)
        _rprint(f"  Downloading {filename}...")

        # Prefer curl, fall back to wget
        if shutil.which("curl"):
            cmd = ["curl", "-L", "-o", str(model_path), "--progress-bar", url]
        elif shutil.which("wget"):
            cmd = ["wget", "-O", str(model_path), "--show-progress", "-q", url]
        else:
            raise RedictumError(
                "Neither curl nor wget found. Install one: "
                "sudo apt install curl"
            )

        result = subprocess.run(cmd)
        if result.returncode != 0 or not model_path.exists():
            if model_path.exists():
                model_path.unlink()
            raise RedictumError(f"Model download failed: {filename}")

        logging.info("Whisper: download complete")
        _rprint(f"  [green]\u2713[/green] Model downloaded: {filename}")
        return model_path

    def _ensure_model(self) -> Path:
        """Check if a model exists, offer to pick existing or download new."""
        config = self._config_mgr.load()
        model_path_str = config.get("dependency", {}).get("whisper_model", "")
        if model_path_str and Path(model_path_str).exists():
            _rprint(f"  [green]\u2713[/green] Model: {Path(model_path_str).name}")
            if not _confirm("  Change model?", default=False):
                return Path(model_path_str)

        # Look for existing models in the models directory
        existing = self._find_existing_models()
        if not existing:
            return self._select_and_download()

        # Offer to pick an existing model or download new
        if _verbosity < 0:
            # Quiet mode: pick first existing model
            selected = existing[0][0]
            _rprint(f"  [green]\u2713[/green] Using model: {selected.name}")
            return selected

        _rprint("\n  [bold]Found installed models:[/bold]")
        for i, (path, size_mb) in enumerate(existing, 1):
            _rprint(f"    {i}. {path.name} ({size_mb})")
        download_idx = len(existing) + 1
        _rprint(f"    {download_idx}. Download new model")

        while True:
            try:
                choice = input(
                    f"\n  Select [1-{download_idx}, default=1]: "
                ).strip()
            except (EOFError, KeyboardInterrupt):
                print()
                choice = ""
            if not choice:
                choice = "1"
            try:
                idx = int(choice)
                if 1 <= idx <= download_idx:
                    break
            except ValueError:
                pass
            _rprint(f"  [red]Invalid choice, enter 1-{download_idx}[/red]")

        if idx == download_idx:
            return self._select_and_download()

        selected = existing[idx - 1][0]
        _rprint(f"  [green]\u2713[/green] Using model: {selected.name}")
        return selected

    def _find_existing_models(self) -> list[tuple[Path, str]]:
        """Find ggml model files in the whisper.cpp models directory.

        Returns:
            List of (path, human_size) tuples, sorted by size descending.
        """
        models_dir = self._install_dir / "models"
        if not models_dir.is_dir():
            return []
        results: list[tuple[Path, str]] = []
        for f in models_dir.glob("ggml-*.bin"):
            if f.name.startswith("for-tests-"):
                continue
            size = f.stat().st_size
            if size < 1024 * 1024:
                continue  # skip tiny/corrupt files
            if size >= 1024 * 1024 * 1024:
                label = f"{size / (1024 ** 3):.1f} GB"
            else:
                label = f"{size / (1024 ** 2):.0f} MB"
            results.append((f, label))
        results.sort(key=lambda x: x[0].stat().st_size, reverse=True)
        return results

    # -- Config --------------------------------------------------------------

    def _update_config(self, cli_path: Path, model_path: Path) -> None:
        """Write whisper paths to config.ini."""
        home = str(Path.home())
        cli_str = str(cli_path)
        model_str = str(model_path)
        if cli_str.startswith(home):
            cli_str = "~" + cli_str[len(home):]
        if model_str.startswith(home):
            model_str = "~" + model_str[len(home):]
        self._config_mgr.update({
            "whisper_cli": cli_str,
            "whisper_model": model_str,
        })
        logging.info("Whisper: config updated cli=%s model=%s", cli_str, model_str)
        _rprint("  [green]\u2713[/green] Config updated")


def setup_logging(log_path: Path, *, force: bool = False, verbose: bool = False) -> None:
    """Configure file-based logging. Called at daemon and interactive startup."""
    log_path.parent.mkdir(parents=True, exist_ok=True)
    logging.basicConfig(
        level=logging.DEBUG if verbose else logging.INFO,
        format="%(asctime)s [%(levelname)s] %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
        handlers=[logging.FileHandler(log_path, encoding="utf-8")],
        force=force,
    )


def _log_system_info() -> None:
    """Log system information snapshot at startup. Never raises."""
    try:
        # OS
        try:
            text = Path("/etc/os-release").read_text()
            m = re.search(r'PRETTY_NAME="?([^"\n]+)"?', text)
            os_name = m.group(1) if m else platform.platform()
        except OSError:
            os_name = platform.platform()
        kernel = platform.release()

        # Python
        py_ver = sys.version.split()[0]

        # Locale & display
        locale_val = os.environ.get("LANG", "unknown")
        display_val = os.environ.get("DISPLAY", "unset")

        # GPU & CUDA via nvidia-smi
        gpu_name = "N/A"
        gpu_driver = "N/A"
        cuda_ver = "N/A"
        try:
            nv = subprocess.run(
                ["nvidia-smi", "--query-gpu=name,driver_version",
                 "--format=csv,noheader"],
                capture_output=True, text=True, timeout=5,
            )
            if nv.returncode == 0 and nv.stdout.strip():
                parts = nv.stdout.strip().split(", ", 1)
                gpu_name = parts[0]
                gpu_driver = parts[1] if len(parts) > 1 else "N/A"
        except (FileNotFoundError, subprocess.TimeoutExpired, OSError):
            pass
        try:
            nv2 = subprocess.run(
                ["nvidia-smi"],
                capture_output=True, text=True, timeout=5,
            )
            if nv2.returncode == 0:
                m = re.search(r"CUDA Version:\s*([\d.]+)", nv2.stdout)
                if m:
                    cuda_ver = m.group(1)
        except (FileNotFoundError, subprocess.TimeoutExpired, OSError):
            pass

        # RAM
        ram_gb = "N/A"
        try:
            for line in Path("/proc/meminfo").read_text().splitlines():
                if line.startswith("MemTotal:"):
                    kb = int(line.split()[1])
                    ram_gb = f"{kb / 1024 / 1024:.1f} GB"
                    break
        except (OSError, ValueError, IndexError):
            pass

        logging.info(
            "System: %s (kernel %s)\n"
            "  Python:  %s\n"
            "  Locale:  %s\n"
            "  Display: %s\n"
            "  GPU:     %s (driver %s)\n"
            "  CUDA:    %s\n"
            "  RAM:     %s",
            os_name, kernel, py_ver, locale_val, display_val,
            gpu_name, gpu_driver, cuda_ver, ram_gb,
        )
    except Exception:
        logging.warning("Failed to collect system info", exc_info=True)


class Daemon:
    """Manage daemon lifecycle: PID file, double-fork, signal handling."""

    def __init__(self, pid_path: Path, log_path: Path) -> None:
        self._pid_path = pid_path
        self._log_path = log_path
        self._stop_event = threading.Event()

    # -- PID management ------------------------------------------------------

    def _read_pid(self) -> int | None:
        """Read PID from file. Return None if missing or invalid."""
        try:
            text = self._pid_path.read_text().strip()
            return int(text)
        except (FileNotFoundError, ValueError):
            return None

    def _is_running(self, pid: int) -> bool:
        """Check if process with given PID is alive (signal 0)."""
        try:
            os.kill(pid, 0)
            return True
        except ProcessLookupError:
            return False
        except PermissionError:
            return True

    def _write_pid(self) -> None:
        """Write current PID to the PID file with explicit permissions."""
        pid_data = f"{os.getpid()}\n".encode()
        flags = os.O_WRONLY | os.O_CREAT
        try:
            fd = os.open(str(self._pid_path), flags | os.O_EXCL, 0o644)
        except FileExistsError:
            fd = os.open(str(self._pid_path), flags | os.O_TRUNC, 0o644)
        try:
            os.write(fd, pid_data)
        finally:
            os.close(fd)

    def _cleanup(self) -> None:
        """Remove PID file (atexit callback)."""
        try:
            self._pid_path.unlink()
        except FileNotFoundError:
            pass

    # -- Signal handling -----------------------------------------------------

    def _setup_signals(self) -> None:
        """Register SIGTERM and SIGINT handlers."""
        signal.signal(signal.SIGTERM, self._handle_signal)
        signal.signal(signal.SIGINT, self._handle_signal)

    def _handle_signal(self, signum: int, frame: Any) -> None:
        """Set stop event on signal."""
        self._stop_event.set()
        logging.info("Received signal %s, shutting down...", signum)

    # -- Public API ----------------------------------------------------------

    def start(self, target: Callable[[], None]) -> None:
        """Daemonize via double-fork and run target function.

        Args:
            target: Callable to run in the daemon process.
        """
        # Check for existing daemon
        pid = self._read_pid()
        if pid is not None:
            if self._is_running(pid):
                raise RedictumError(
                    f"Daemon is already running (PID {pid})."
                )
            # Stale PID file — clean up
            self._cleanup()

        # First fork
        try:
            pid = os.fork()
        except OSError as exc:
            raise RedictumError(f"First fork failed: {exc}") from exc
        if pid > 0:
            # Parent — wait briefly for child to settle, then exit
            return

        # Child 1: new session                      # pragma: no cover
        os.setsid()                                  # pragma: no cover
        os.umask(0o022)                              # pragma: no cover

        # Second fork
        try:                                         # pragma: no cover
            pid = os.fork()                          # pragma: no cover
        except OSError:                              # pragma: no cover
            sys.exit(1)                              # pragma: no cover
        if pid > 0:                                  # pragma: no cover
            # Child 1 exits
            sys.exit(0)                              # pragma: no cover

        # Daemon process (child 2)
        # Redirect std file descriptors
        devnull = os.open(os.devnull, os.O_RDWR)    # pragma: no cover
        os.dup2(devnull, sys.stdin.fileno())         # pragma: no cover

        # Redirect stdout/stderr to log file
        log_fd = os.open(                            # pragma: no cover
            str(self._log_path),
            os.O_WRONLY | os.O_CREAT | os.O_APPEND,
            0o644,
        )
        os.dup2(log_fd, sys.stdout.fileno())         # pragma: no cover
        os.dup2(log_fd, sys.stderr.fileno())         # pragma: no cover
        os.close(devnull)                            # pragma: no cover
        os.close(log_fd)                             # pragma: no cover

        # Re-init logging in forked child (clears parent handlers)
        setup_logging(self._log_path, force=True, verbose=(_verbosity > 0))  # pragma: no cover

        # Write PID file and register cleanup
        self._write_pid()                            # pragma: no cover
        atexit.register(self._cleanup)               # pragma: no cover

        # Setup signal handlers
        self._setup_signals()                        # pragma: no cover

        logging.info("Daemon started (PID %d)", os.getpid())  # pragma: no cover

        # Run the target
        try:                                         # pragma: no cover
            target()                                 # pragma: no cover
        except Exception:                            # pragma: no cover
            logging.exception("Daemon target crashed")  # pragma: no cover
        finally:                                     # pragma: no cover
            logging.info("Daemon stopped (PID %d)", os.getpid())  # pragma: no cover

    def stop(self) -> None:
        """Send SIGTERM to the running daemon and wait for it to exit."""
        pid = self._read_pid()
        if pid is None:
            raise RedictumError("Daemon is not running (no PID file).")
        if not self._is_running(pid):
            # Stale PID — clean up
            self._cleanup()
            raise RedictumError("Daemon is not running (stale PID file removed).")

        os.kill(pid, signal.SIGTERM)

        # Wait for process to exit
        deadline = time.monotonic() + STOP_TIMEOUT
        while time.monotonic() < deadline:
            if not self._is_running(pid):
                return
            time.sleep(0.1)

        _rprint(
            f"[yellow]Warning: daemon (PID {pid}) did not exit within "
            f"{STOP_TIMEOUT}s after SIGTERM.[/yellow]"
        )

    def status(self) -> int | None:
        """Return PID if daemon is running, None otherwise. Cleans stale PID."""
        pid = self._read_pid()
        if pid is None:
            return None
        if self._is_running(pid):
            return pid
        # Stale PID
        self._cleanup()
        return None

    @property
    def stop_event(self) -> threading.Event:
        """Event for the main loop to wait on."""
        return self._stop_event


class AudioRecorder:
    """Record microphone audio via arecord."""

    def __init__(self, output_dir: Path, device: str) -> None:
        self._output_dir = output_dir
        self._device = device
        self._process: subprocess.Popen[bytes] | None = None
        self._current_file: Path | None = None

    def start(self) -> None:
        """Begin recording audio to a timestamped WAV file."""
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        self._current_file = self._output_dir / f"rec_{ts}.wav"
        self._process = subprocess.Popen(
            [
                "arecord",
                "-D", self._device,
                "-f", "S16_LE",
                "-r", str(AUDIO_SAMPLE_RATE),
                "-c", str(AUDIO_CHANNELS),
                "-t", "wav",
                str(self._current_file),
            ],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        logging.info("Recording started: %s", self._current_file.name)

    def stop(self) -> Path | None:
        """Stop recording and return the path to the WAV file.

        Returns:
            Path to the recorded WAV file, or None on failure.
        """
        if self._process is None:
            return None
        self._process.terminate()
        try:
            self._process.wait(timeout=5)
        except subprocess.TimeoutExpired:
            self._process.kill()
            self._process.wait()
            logging.warning("arecord did not stop gracefully, killed")
        rc = self._process.returncode
        # arecord returns 1 or -15 (SIGTERM) when we terminate it — expected.
        if rc not in (0, 1, -signal.SIGTERM):
            logging.error("arecord exited with code %d", rc)
        self._process = None

        path = self._current_file
        self._current_file = None
        if path is None or not path.exists() or path.stat().st_size == 0:
            logging.warning("Recording file empty or missing: %s", path)
            if path and path.exists():
                path.unlink()
            return None
        logging.info("Recording stopped: %s", path.name)
        return path

    def cancel(self) -> None:
        """Terminate recording and delete the file. For graceful shutdown."""
        if self._process is not None:
            self._process.terminate()
            try:
                self._process.wait(timeout=2)
            except subprocess.TimeoutExpired:
                self._process.kill()
                self._process.wait()
            self._process = None
        if self._current_file and self._current_file.exists():
            self._current_file.unlink()
            self._current_file = None


class AudioProcessor:
    """Normalize audio via ffmpeg."""

    def normalize(self, input_path: Path) -> Path:
        """Normalize audio levels of the given file.

        Args:
            input_path: Path to the raw audio file.

        Returns:
            Path to the normalized audio file, or *input_path* if ffmpeg
            is not installed.

        Raises:
            RedictumError: If ffmpeg fails.
        """
        if not shutil.which("ffmpeg"):
            logging.warning("ffmpeg not found, skipping normalization")
            return input_path
        output_path = input_path.with_stem(input_path.stem + "_norm")
        try:
            result = subprocess.run(
                [
                    "ffmpeg",
                    "-i", str(input_path),
                    "-af", "loudnorm",
                    "-ar", str(AUDIO_SAMPLE_RATE),
                    "-ac", str(AUDIO_CHANNELS),
                    "-y",
                    str(output_path),
                ],
                stderr=subprocess.PIPE,
                stdout=subprocess.DEVNULL,
                timeout=60,
            )
        except subprocess.TimeoutExpired as exc:
            raise RedictumError("ffmpeg normalization timed out") from exc
        if result.returncode != 0:
            stderr_text = result.stderr.decode(errors='replace')
            logging.error("ffmpeg normalization stderr:\n%s", stderr_text)
            raise RedictumError(
                f"ffmpeg normalization failed (code {result.returncode}): "
                f"{stderr_text.strip()[-500:]}"
            )
        _rprint(f"  Normalize: {input_path.name} → {output_path.name}", level=1)
        logging.info(
            "Audio normalized: %s -> %s", input_path.name, output_path.name
        )
        return output_path

    @staticmethod
    def has_speech(audio_path: Path, threshold: float = SILENCE_RMS_THRESHOLD) -> bool:
        """Check if audio contains speech by measuring RMS energy.

        Args:
            audio_path: Path to a 16-bit PCM WAV file.
            threshold: RMS level below which audio is considered silence.

        Returns:
            True if RMS is above threshold (likely contains speech).
        """
        with open(audio_path, "rb") as f:
            # Validate RIFF/WAVE header
            riff = f.read(12)
            if len(riff) < 12 or riff[:4] != b"RIFF" or riff[8:12] != b"WAVE":
                logging.warning("Not a valid WAV file: %s", audio_path)
                return False
            # Scan chunks until "data" is found
            data = b""
            while True:
                chunk_hdr = f.read(8)
                if len(chunk_hdr) < 8:
                    break
                chunk_id = chunk_hdr[:4]
                chunk_size = struct.unpack("<I", chunk_hdr[4:8])[0]
                if chunk_id == b"data":
                    data = f.read(chunk_size)
                    break
                f.seek(chunk_size, 1)  # skip non-data chunk
        if len(data) < 2:
            return False
        samples = struct.unpack(f"<{len(data) // 2}h", data)
        rms = (sum(s * s for s in samples) / len(samples)) ** 0.5
        _rprint(f"  RMS: {rms:.0f}, threshold: {threshold:.0f}", level=1)
        logging.info("Audio RMS: %.1f (threshold: %.1f)", rms, threshold)
        return rms > threshold


def _detect_language() -> str:
    """Detect language code from system locale (e.g., 'ru', 'en', 'uk').

    Returns:
        Two-letter ISO 639-1 language code, or empty string if
        detection fails.
    """
    loc = os.environ.get("LANG", "") or os.environ.get("LC_ALL", "")
    # loc is like "ru_RU.UTF-8" or "ru_RU" or "en_US.UTF-8"
    if "_" in loc:
        return loc.split("_")[0].lower()
    if loc and len(loc) >= 2:
        return loc[:2].lower()
    return ""


LANGUAGE_PROMPTS: dict[str, str] = {
    "en": "So, here's the thing: we had a meeting yesterday — about fifteen people showed up. The agenda covered three points: scheduling, budget, and next steps. Someone asked whether we could finish by Friday. Honestly, I think we can… but it won't be easy! Let me explain why.",
    "zh": "这件事情是这样的：我们昨天开了个会——大概有十五个人参加。议程包括三个议题：时间安排、预算和下一步计划。有人问我们能不能在周五前完成。老实说，我觉得可以……但不会很轻松！让我来解释一下。",
    "hi": "देखिए, मामला कुछ ऐसा है: कल हमारी बैठक हुई — करीब पंद्रह लोग आए। एजेंडे में तीन बिंदु थे: समयसारणी, बजट और अगले कदम। किसी ने पूछा कि क्या हम शुक्रवार तक खत्म कर सकते हैं। सच कहूं तो, शायद… लेकिन आसान नहीं होगा!",
    "es": "Mira, la cosa es así: ayer tuvimos una reunión — llegaron unas quince personas. El orden del día tenía tres puntos: horarios, presupuesto y próximos pasos. Alguien preguntó si podíamos terminar para el viernes. Honestamente, creo que sí… ¡pero no será fácil! Déjame explicarte por qué.",
    "ar": "الأمر كالتالي: كان لدينا اجتماع أمس — حضر خمسة عشر شخصاً تقريباً. تضمّن جدول الأعمال ثلاثة بنود: الجدولة الزمنية، الميزانية، والخطوات التالية. سأل أحدهم إن كنا نستطيع الانتهاء بحلول الجمعة. بصراحة، أعتقد ذلك… لكنّها لن تكون سهلة!",
    "fr": "Voilà la situation : hier, on a eu une réunion — une quinzaine de personnes étaient présentes. L'ordre du jour comportait trois points : le planning, le budget et les prochaines étapes. Quelqu'un a demandé si on pouvait terminer d'ici vendredi. Honnêtement, je pense que oui… mais ce ne sera pas facile ! Laissez-moi vous expliquer pourquoi.",
    "pt": "Veja bem, a situação é a seguinte: tivemos uma reunião ontem — umas quinze pessoas apareceram. A pauta tinha três pontos: cronograma, orçamento e próximos passos. Alguém perguntou se conseguíamos terminar até sexta. Sinceramente, acho que sim… mas não será fácil! Deixa eu explicar o porquê.",
    "ru": "Вот в чём дело: вчера у нас была встреча — примерно пятнадцать человек. Обсудили три вопроса: расписание, бюджет и дальнейшие шаги. Кто-то спросил, успеем ли мы до пятницы. Честно говоря, думаю, да… но легко не будет! Дайте объясню.",
    "de": "Also, die Sache ist so: Gestern hatten wir eine Besprechung — etwa fünfzehn Leute sind gekommen. Auf der Tagesordnung standen drei Punkte: Zeitplanung, Budget und nächste Schritte. Jemand fragte, ob wir das bis Freitag abschließen können. Ehrlich gesagt denke ich, wir schaffen das… aber es wird nicht einfach! Ich erkläre euch warum.",
    "ja": "さて、こういうことです：昨日ミーティングがありました——十五人ほど参加しました。議題は三つありました：スケジュール、予算、次のステップです。金曜日までに終わるかどうか誰かが聞きました。正直に言えば、できると思います…でも簡単ではないはずです！理由を説明させてください。",
    "uk": "Отже, справа така: вчора у нас була зустріч — десь п'ятнадцять осіб. Обговорили три питання: розклад, бюджет і подальші кроки. Хтось запитав, чи встигнемо до п'ятниці. Чесно кажучи, думаю, що так… але легко не буде! Дайте поясню, чому.",
    "ko": "자, 상황은 이러합니다: 어제 회의가 있었는데 — 대략 열다섯 명이 왔어요. 안건은 세 가지였죠: 일정, 예산, 그리고 다음 단계입니다. 누군가 금요일까지 끝낼 수 있는지 물었어요. 솔직히 말하면, 가능하다고 생각해요… 하지만 쉬운 일은 아니에요! 이유를 설명해 드릴게요.",
    "it": "Ecco la situazione: ieri abbiamo avuto una riunione — una quindicina di persone si è presentata. L'ordine del giorno comprendeva tre punti: la pianificazione, il budget e i prossimi passi. Qualcuno ha chiesto se riusciamo a finire entro venerdì. Sinceramente, credo di sì… ma non sarà facile! Vi spiego il perché.",
    "tr": "Bak, durum şöyle: dün bir toplantı vardı — yaklaşık on beş kişi geldi. Gündemdeki üç madde şunlardı: takvim, bütçe ve sonraki adımlar. Biri cuma gününe kadar bitirebilir miyiz diye sordu. Dürüst olmak gerekirse, sanırım evet… ama kolay olmayacak! Neden olduğunu açıklayım.",
    "pl": "Więc, sprawa wygląda tak: wczoraj mieliśmy spotkanie — przyszło około piętnastu osób. Agenda obejmowała trzy punkty: harmonogram, budżet i kolejne kroki. Ktoś zapytał, czy zdążymy do piątku. Szczerze mówiąc, myślę, że tak… ale nie będzie łatwo! Wyjaśnię wam dlaczego.",
}

LANGUAGE_NAMES: dict[str, str] = {
    "en": "English",
    "zh": "中文",
    "hi": "हिन्दी",
    "es": "Español",
    "ar": "العربية",
    "fr": "Français",
    "pt": "Português",
    "ru": "Русский",
    "de": "Deutsch",
    "ja": "日本語",
    "uk": "Українська",
    "ko": "한국어",
    "it": "Italiano",
    "tr": "Türkçe",
    "pl": "Polski",
}


def _show_language_status(config: dict[str, Any]) -> str:
    """Show current language + prompt status from config.

    Returns:
        Detected language code (from locale).
    """
    dep = config.get("dependency", {})
    lang = dep.get("whisper_language", "auto")
    prompt = dep.get("whisper_prompt", "auto")
    detected = _detect_language()

    _rprint("[bold]Current language settings:[/bold]")
    if lang == "auto":
        if detected:
            name = LANGUAGE_NAMES.get(detected, detected)
            _rprint(f"  Language: [cyan]auto[/cyan] (detected: {detected} — {name})")
        else:
            _rprint("  Language: [cyan]auto[/cyan] (could not detect from locale)")
    else:
        name = LANGUAGE_NAMES.get(lang, lang)
        _rprint(f"  Language: [cyan]{lang}[/cyan] ({name})")

    if prompt == "auto":
        _rprint("  Prompt:   [cyan]auto[/cyan] (selected by language)")
    elif prompt:
        short = prompt[:60] + "..." if len(prompt) > 60 else prompt
        _rprint(f"  Prompt:   {short}")
    else:
        _rprint("  Prompt:   [yellow](empty)[/yellow]")

    return detected


def _language_wizard(detected_lang: str) -> tuple[str, str] | None:  # pragma: no cover
    """Interactive language selector wizard.

    Args:
        detected_lang: Language code detected from system locale.

    Returns:
        ``(language, prompt)`` tuple, or ``None`` if user cancels.
    """
    codes = list(LANGUAGE_NAMES.keys())

    _rprint("\n[bold]Select transcription language:[/bold]\n")
    for i, code in enumerate(codes, 1):
        name = LANGUAGE_NAMES[code]
        marker = " [green]★[/green]" if code == detected_lang else ""
        _rprint(f"  {i:2d}. {code} — {name}{marker}")
    _rprint("   0. Other (enter code manually)")
    _rprint("   A. Auto (detect from system locale)\n")

    try:
        choice = input("Enter choice: ").strip()
    except (EOFError, KeyboardInterrupt):
        print()
        return None

    if not choice:
        return None

    if choice.upper() == "A":
        return ("auto", "auto")

    if choice == "0":
        try:
            code = input("Enter language code (e.g. 'nl', 'sv'): ").strip().lower()
        except (EOFError, KeyboardInterrupt):
            print()
            return None
        if not code:
            return None
        prompt = LANGUAGE_PROMPTS.get(code, "")
        return (code, prompt)

    try:
        idx = int(choice)
    except ValueError:
        _rprint(f"[red]Invalid choice: {choice}[/red]")
        return None

    if 1 <= idx <= len(codes):
        code = codes[idx - 1]
        return (code, LANGUAGE_PROMPTS.get(code, ""))

    _rprint(f"[red]Invalid choice: {choice}[/red]")
    return None


class Transcriber:
    """Transcribe audio via whisper.cpp CLI."""

    BLANK_MARKERS = {"[BLANK_AUDIO]", "[ЗВУК]", "(silence)"}

    def __init__(
        self,
        whisper_cli: str,
        model_path: str,
        language: str,
        prompt: str = "",
        timeout: int = 120,
    ) -> None:
        cli = Path(whisper_cli)
        if not cli.exists():
            raise RedictumError(f"Whisper CLI not found: {cli}")
        if not os.access(cli, os.X_OK):
            raise RedictumError(f"Whisper CLI is not executable: {cli}")
        model = Path(model_path)
        if not model.is_file():
            raise RedictumError(f"Whisper model not found: {model}")
        self._cli = str(cli)
        self._model = str(model)
        self._language = language
        self._prompt = prompt
        self._timeout = timeout

    def _resolve_prompt(self) -> str | None:
        """Pick the right prompt for transcription.

        Priority:
        1. "auto" -> select from LANGUAGE_PROMPTS by language
        2. Non-empty string -> use as-is (user override)
        3. Empty string -> no prompt (disabled)
        """
        if self._prompt == "auto":
            return LANGUAGE_PROMPTS.get(self._language)
        if self._prompt:
            return self._prompt
        return None

    def transcribe(self, audio_path: Path, translate: bool = False) -> str:
        """Transcribe the given audio file to text.

        Args:
            audio_path: Path to the audio file.
            translate: If True, also translate to English via --translate.

        Returns:
            Transcribed text string (empty if nothing useful detected).

        Raises:
            RedictumError: If whisper-cli fails or times out.
        """
        cmd = [
            self._cli,
            "-m", self._model,
            "-f", str(audio_path),
            "--no-timestamps",
            "-np",
        ]
        if translate:
            # No -l flag: whisper auto-detects source language
            # and --translate outputs English
            cmd.append("--translate")
        elif self._language:
            cmd.extend(["-l", self._language])
        if not translate:
            prompt = self._resolve_prompt()
            if prompt:
                cmd.extend(["--prompt", prompt])

        _rprint(f"  Whisper cmd: {' '.join(cmd)}", level=1)
        logging.info(
            "Transcribing: %s (translate: %s)", audio_path.name, translate,
        )

        t0 = time.monotonic()
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self._timeout,
            )
        except subprocess.TimeoutExpired as exc:
            raise RedictumError(
                f"Transcription timed out after {self._timeout}s"
            ) from exc

        if result.returncode != 0:
            logging.error("whisper-cli stderr:\n%s", result.stderr)
            logging.error("whisper-cli stdout:\n%s", result.stdout)
            raise RedictumError(
                f"whisper-cli failed (code {result.returncode}): "
                f"{result.stderr.strip()[-500:]}"
            )

        text = result.stdout.strip()
        elapsed = time.monotonic() - t0
        _rprint(f"  Whisper: {len(text)} chars in {elapsed:.1f}s", level=1)
        # Filter blank audio artifacts
        if not text or text in self.BLANK_MARKERS:
            logging.info("Whisper returned blank/empty output")
            return ""
        return text


class ClipboardManager:
    """Copy text to clipboard, paste via xdotool, save/restore contents.

    Supports saving and restoring text and binary clipboard data (images,
    file lists) so that the user's clipboard is preserved across paste
    operations.
    """

    # X11 protocol targets — not actual data, skip when saving.
    _SKIP_TARGETS = frozenset({
        "TARGETS", "MULTIPLE", "SAVE_TARGETS", "TIMESTAMP", "DELETE",
        "INCR", "INSERT_PROPERTY", "INSERT_SELECTION", "MANAGER",
    })

    # Target patterns we know how to save and restore.
    _SUPPORTED_PREFIXES = ("text/", "image/", "UTF8_STRING", "STRING", "TEXT")

    def copy(self, text: str) -> None:
        """Copy text to the system clipboard via xclip."""
        try:
            result = subprocess.run(
                ["xclip", "-selection", "clipboard"],
                input=text.encode("utf-8"),
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                timeout=5,
            )
            if result.returncode != 0:
                logging.warning("xclip copy failed (code %d)", result.returncode)
        except subprocess.TimeoutExpired:
            logging.warning("xclip copy timed out")
        except (FileNotFoundError, OSError) as exc:
            logging.warning("xclip copy failed: %s", exc)

    def paste(self) -> None:
        """Simulate Ctrl+V to paste from clipboard."""
        time.sleep(0.05)
        try:
            result = subprocess.run(
                ["xdotool", "key", "--clearmodifiers", "ctrl+v"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                timeout=5,
            )
            if result.returncode != 0:
                logging.warning("xdotool paste failed (code %d)", result.returncode)
        except subprocess.TimeoutExpired:
            logging.warning("xdotool paste timed out")
        except (FileNotFoundError, OSError) as exc:
            logging.warning("xdotool paste failed: %s", exc)

    def save(self) -> tuple[str, bytes] | None:
        """Save current clipboard contents (target type + raw data).

        Returns:
            ``(target, data)`` tuple or ``None`` if clipboard is empty
            or contains unsupported content.
        """
        target = self._detect_target()
        if target is None:
            return None
        try:
            result = subprocess.run(
                ["xclip", "-selection", "clipboard", "-t", target, "-o"],
                capture_output=True,
                timeout=5,
            )
            if result.returncode != 0 or not result.stdout:
                logging.warning("Clipboard save failed: xclip returned %d", result.returncode)
                return None
            _rprint(f"  Clipboard saved: {target}, {len(result.stdout)} bytes", level=1)
            return (target, result.stdout)
        except (subprocess.TimeoutExpired, FileNotFoundError) as exc:
            logging.warning("Clipboard save failed: %s", exc)
            return None

    def restore(self, snapshot: tuple[str, bytes]) -> None:
        """Restore previously saved clipboard contents.

        Args:
            snapshot: ``(target, data)`` tuple from ``save()``.
        """
        target, data = snapshot
        try:
            subprocess.run(
                ["xclip", "-selection", "clipboard", "-t", target],
                input=data,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                timeout=5,
            )
            _rprint(f"  Clipboard restored: {target}", level=1)
        except (subprocess.TimeoutExpired, FileNotFoundError) as exc:
            logging.warning("Clipboard restore failed: %s", exc)

    def _detect_target(self) -> str | None:
        """Detect the best clipboard target to save.

        Reads the TARGETS list from xclip, filters out X11 internal
        targets, and returns the first supported one (most specific
        format as advertised by the clipboard owner).
        """
        try:
            result = subprocess.run(
                ["xclip", "-selection", "clipboard", "-t", "TARGETS", "-o"],
                capture_output=True,
                text=True,
                timeout=5,
            )
            if result.returncode != 0 or not result.stdout:
                return None
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return None

        for line in result.stdout.splitlines():
            target = line.strip()
            if not target or target in self._SKIP_TARGETS:
                continue
            if any(target.startswith(p) for p in self._SUPPORTED_PREFIXES):
                return target
        return None


class VolumeController:
    """Reduce system volume during recording, restore on stop.

    Uses ``pactl`` to manipulate the default PulseAudio/PipeWire sink volume.
    All calls are best-effort — failures are logged but never break recording.
    Thread-safe: all access to saved state is protected by an internal lock.

    Multi-instance safe: a shared lock file in ``XDG_RUNTIME_DIR`` tracks the
    original (pre-reduction) volume and a list of active PIDs.  Only the last
    instance to finish restores the original volume.
    """

    _LOCK_FILENAME = "redictum-volume.json"

    def __init__(self, volume_level: int) -> None:
        self._volume_level = max(0, min(100, volume_level))
        self._lock = threading.Lock()
        self._active = False
        self._pid = os.getpid()
        self._lock_path = self._resolve_lock_path()

    @classmethod
    def _resolve_lock_path(cls) -> Path:
        """Return path for the shared volume lock file.

        Prefers ``XDG_RUNTIME_DIR`` (per-user tmpfs, mode 0700).
        Falls back to ``/tmp/redictum-volume-<uid>.json``.
        """
        runtime_dir = os.environ.get("XDG_RUNTIME_DIR")
        if runtime_dir and Path(runtime_dir).is_dir():
            return Path(runtime_dir) / cls._LOCK_FILENAME
        return Path(f"/tmp/redictum-volume-{os.getuid()}.json")

    @staticmethod
    def _pid_alive(pid: int) -> bool:
        """Check if a process with the given PID is alive."""
        try:
            os.kill(pid, 0)
            return True
        except ProcessLookupError:
            return False
        except (PermissionError, OSError):
            return True  # process exists but owned by another user

    @staticmethod
    def _get_current_volume() -> int | None:
        """Read current default sink volume percentage via pactl."""
        try:
            result = subprocess.run(
                ["pactl", "get-sink-volume", "@DEFAULT_SINK@"],
                capture_output=True, text=True, timeout=2,
            )
            match = re.search(r"(\d+)%", result.stdout)
            if match:
                return int(match.group(1))
            logging.warning("Could not parse sink volume: %s", result.stdout.strip())
        except (subprocess.TimeoutExpired, FileNotFoundError, OSError):
            logging.warning("pactl get-sink-volume failed")
        return None

    @staticmethod
    def _set_volume(percent: int) -> None:
        """Set default sink volume to an absolute percentage."""
        try:
            subprocess.run(
                ["pactl", "set-sink-volume", "@DEFAULT_SINK@", f"{percent}%"],
                capture_output=True, timeout=2,
            )
        except (subprocess.TimeoutExpired, FileNotFoundError, OSError):
            logging.warning("pactl set-sink-volume failed")

    def _shared_acquire(self, current_volume: int) -> int | None:
        """Register this PID in the shared lock file.

        Returns the original (pre-reduction) volume percentage, or None on
        failure.  The first instance to register saves the current volume as
        the original.  Subsequent instances reuse that value.  Dead PIDs from
        crashed instances are cleaned up automatically.
        """
        pid = self._pid
        try:
            fd = os.open(str(self._lock_path), os.O_RDWR | os.O_CREAT, 0o600)
        except OSError:
            logging.warning("Cannot open volume lock file: %s", self._lock_path)
            return None
        try:
            fcntl.flock(fd, fcntl.LOCK_EX)
            raw = b""
            while True:
                chunk = os.read(fd, 4096)
                if not chunk:
                    break
                raw += chunk
            data: dict[str, Any] = {}
            if raw.strip():
                try:
                    data = json.loads(raw)
                except (json.JSONDecodeError, ValueError):
                    data = {}
            # Clean dead PIDs
            pids: list[int] = [
                p for p in data.get("pids", [])
                if isinstance(p, int) and self._pid_alive(p)
            ]
            # Validate stored volume
            stored = data.get("volume")
            if not isinstance(stored, int) or stored < 0 or stored > 200:
                stored = None
            if pids and stored is not None:
                original = stored
            else:
                original = current_volume
            if pid not in pids:
                pids.append(pid)
            new_data = {"volume": original, "pids": pids}
            os.lseek(fd, 0, os.SEEK_SET)
            os.ftruncate(fd, 0)
            os.write(fd, json.dumps(new_data).encode())
            return original
        except OSError:
            logging.warning("Volume lock acquire failed")
            return None
        finally:
            try:
                fcntl.flock(fd, fcntl.LOCK_UN)
            except OSError:
                pass
            os.close(fd)

    def _shared_release(self) -> int | None:
        """Unregister this PID from the shared lock file.

        Returns the original volume to restore if this was the last active
        instance, or None if other instances are still running.
        """
        pid = self._pid
        try:
            fd = os.open(str(self._lock_path), os.O_RDWR, 0o600)
        except FileNotFoundError:
            return None
        except OSError:
            logging.warning("Cannot open volume lock file for release")
            return None
        try:
            fcntl.flock(fd, fcntl.LOCK_EX)
            raw = b""
            while True:
                chunk = os.read(fd, 4096)
                if not chunk:
                    break
                raw += chunk
            data: dict[str, Any] = {}
            if raw.strip():
                try:
                    data = json.loads(raw)
                except (json.JSONDecodeError, ValueError):
                    data = {}
            pids: list[int] = [
                p for p in data.get("pids", [])
                if isinstance(p, int) and p != pid and self._pid_alive(p)
            ]
            stored = data.get("volume")
            if not isinstance(stored, int) or stored < 0 or stored > 200:
                stored = None
            if not pids:
                # Last instance — clean up
                os.ftruncate(fd, 0)
                try:
                    self._lock_path.unlink()
                except OSError:
                    pass
                return stored
            # Other instances still active — update file
            new_data = {"volume": stored, "pids": pids}
            os.lseek(fd, 0, os.SEEK_SET)
            os.ftruncate(fd, 0)
            os.write(fd, json.dumps(new_data).encode())
            return None
        except OSError:
            logging.warning("Volume lock release failed")
            return None
        finally:
            try:
                fcntl.flock(fd, fcntl.LOCK_UN)
            except OSError:
                pass
            try:
                os.close(fd)
            except OSError:
                pass

    def reduce(self) -> None:
        """Save current sink volume, then reduce to configured percentage."""
        with self._lock:
            if self._active:
                return
            current = self._get_current_volume()
            if current is None:
                return
            original = self._shared_acquire(current)
            if original is None:
                return
            target = int(original * self._volume_level / 100)
            self._active = True
        self._set_volume(target)
        logging.info("Volume reduced to %d%% (was %d%%)", target, original)

    def restore(self) -> None:
        """Restore previously saved volume. Safe to call multiple times."""
        with self._lock:
            if not self._active:
                return
            self._active = False
            volume = self._shared_release()
        if volume is not None:
            self._set_volume(volume)
            logging.info("Volume restored to %d%%", volume)
        else:
            logging.info("Volume restore deferred (other instances active)")


class SoundNotifier:
    """Play WAV feedback tones via paplay.

    Tones are procedurally generated lazily on first play and cached as
    temporary WAV files. See ``_generate_tones()`` at the bottom
    of this module for the synthesis code.
    """

    def __init__(self, volume: int = 30) -> None:
        self._volume = max(0, min(100, volume))
        self._temp_dir: Path | None = None
        self._sounds: dict[str, Path] = {}
        self._init_lock = threading.Lock()
        self._warned_no_paplay = False

    def play_start(self) -> None:
        """Play the 'recording started' tone."""
        self._play("start")

    def play_processing(self) -> None:
        """Play the 'transcription in progress' tone."""
        self._play("processing")

    def play_stop(self) -> None:
        """Play the 'pipeline complete' tone."""
        self._play("done")

    def play_error(self) -> None:
        """Play the 'error occurred' tone."""
        self._play("error")

    def cleanup(self) -> None:
        """Remove temporary WAV files."""
        if self._temp_dir is not None:
            shutil.rmtree(self._temp_dir, ignore_errors=True)

    # -- internals -----------------------------------------------------------

    def _ensure_tones(self) -> None:
        """Generate and cache all WAV tones on first use (thread-safe)."""
        if self._sounds:
            return
        with self._init_lock:
            if self._sounds:
                return
            self._temp_dir = Path(tempfile.mkdtemp(prefix="redictum_"))
            for name, samples in _generate_tones().items():
                self._sounds[name] = self._write_wav(f"{name}.wav", samples)

    def _play(self, name: str) -> None:
        self._ensure_tones()
        wav_path = self._sounds.get(name)
        if wav_path is None or not wav_path.exists():
            return
        vol_scaled = int(self._volume / 100 * 65536)
        try:
            proc = subprocess.Popen(
                ["paplay", f"--volume={vol_scaled}", str(wav_path)],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            threading.Thread(target=proc.wait, daemon=True).start()
        except FileNotFoundError:
            if not self._warned_no_paplay:
                logging.warning("paplay not found, sound notifications disabled")
                self._warned_no_paplay = True

    def _write_wav(self, filename: str, samples: list[float]) -> Path:
        peak = max(abs(s) for s in samples) or 1.0
        pcm = b"".join(
            struct.pack("<h", max(-32767, min(32767, int(s / peak * 30000))))
            for s in samples
        )
        n = len(pcm)
        header = struct.pack(
            "<4sI4s4sIHHIIHH4sI",
            b"RIFF", 36 + n, b"WAVE",
            b"fmt ", 16, 1, 1, 44100, 88200, 2, 16,
            b"data", n,
        )
        path = self._temp_dir / filename
        path.write_bytes(header + pcm)
        return path


class HotkeyListener:
    """Push-to-talk hotkey listener via pynput.

    Hold the key for hold_delay seconds to start recording.
    Release the key to trigger processing.
    """

    # Mapping of config string names to pynput Key attributes
    _KEY_MAP: dict[str, str] = {
        "insert": "insert",
        "delete": "delete",
        "home": "home",
        "end": "end",
        "page_up": "page_up",
        "page_down": "page_down",
        "space": "space",
        "enter": "enter",
        "tab": "tab",
        "backspace": "backspace",
        "pause": "pause",
        "scroll_lock": "scroll_lock",
        "print_screen": "print_screen",
        "caps_lock": "caps_lock",
        "num_lock": "num_lock",
        "escape": "esc",
        "esc": "esc",
    }

    _MODIFIER_MAP: dict[str, tuple[str, ...]] = {
        "ctrl":  ("ctrl_l", "ctrl_r"),
        "alt":   ("alt_l", "alt_r", "alt_gr"),
        "shift": ("shift_l", "shift_r"),
    }

    def __init__(self, hotkey: str, hold_delay: float, translate_key: str = "") -> None:
        self._hotkey = hotkey
        self._translate_key = translate_key
        self._hold_delay = hold_delay
        self._target_key: Any = None
        self._target_mods: frozenset[Any] = frozenset()
        self._translate_target_key: Any = None
        self._translate_target_mods: frozenset[Any] = frozenset()
        self._held_mods: set[Any] = set()
        self._all_mod_keys: frozenset[Any] = frozenset()
        self._listener: Any = None
        self._hold_timer: threading.Timer | None = None
        self._is_holding = False
        self._pending_mode: str = "transcribe"
        self._on_hold: Callable[[str], None] | None = None
        self._on_release: Callable[[str], None] | None = None

    def start(self, on_hold: Callable[[str], None], on_release: Callable[[str], None]) -> None:
        """Start listening for the push-to-talk hotkey.

        Args:
            on_hold: Called with mode ("transcribe"/"translate") when key
                     is held longer than hold_delay.
            on_release: Called with mode when key is released after hold.
        """
        from pynput.keyboard import Key, Listener

        self._on_hold = on_hold
        self._on_release = on_release
        self._target_key, self._target_mods = self._parse_combo(self._hotkey)
        if self._translate_key:
            self._translate_target_key, self._translate_target_mods = \
                self._parse_combo(self._translate_key)
        # Collect all pynput Key objects for modifiers
        all_mods: set[Any] = set()
        for key_names in self._MODIFIER_MAP.values():
            for name in key_names:
                if hasattr(Key, name):
                    all_mods.add(getattr(Key, name))
        self._all_mod_keys = frozenset(all_mods)
        self._listener = Listener(
            on_press=self._on_press,
            on_release=self._on_key_release,
        )
        self._listener.start()
        logging.info(
            "Hotkey listener started: %s (hold %.1fs), translate: %s",
            self._hotkey, self._hold_delay, self._translate_key or "disabled",
        )

    def stop(self) -> None:
        """Stop the hotkey listener and cancel any pending timer."""
        if self._hold_timer is not None:
            self._hold_timer.cancel()
            self._hold_timer = None
        if self._listener is not None:
            self._listener.stop()
            self._listener = None

    def _on_press(self, key: Any) -> None:
        """Handle key press: track modifiers and start hold timer."""
        if key in self._all_mod_keys:
            self._held_mods.add(key)
            return
        mode = self._resolve_mode(key)
        if mode is None:
            return
        if self._is_holding or self._hold_timer is not None:
            return
        self._pending_mode = mode
        self._hold_timer = threading.Timer(self._hold_delay, self._fire_hold)
        self._hold_timer.daemon = True
        self._hold_timer.start()

    def _fire_hold(self) -> None:
        """Called when hold_delay expires — trigger on_hold callback."""
        self._is_holding = True
        self._hold_timer = None
        if self._on_hold:
            self._on_hold(self._pending_mode)

    def _on_key_release(self, key: Any) -> None:
        """Handle key release: track modifiers, cancel timer or trigger on_release."""
        if key in self._all_mod_keys:
            self._held_mods.discard(key)
            return
        if not (key == self._target_key or key == self._translate_target_key):
            return
        if self._hold_timer is not None:
            self._hold_timer.cancel()
            self._hold_timer = None
        if self._is_holding:
            self._is_holding = False
            if self._on_release:
                self._on_release(self._pending_mode)

    def _resolve_mode(self, key: Any) -> str | None:
        """Determine mode from pressed key + held modifiers.

        Priority: translate (more specific combo) > transcribe.
        """
        if (self._translate_target_key is not None
                and key == self._translate_target_key
                and self._mods_match(self._translate_target_mods)):
            return "translate"
        if key == self._target_key and self._mods_match(self._target_mods):
            return "transcribe"
        return None

    def _mods_match(self, required_mods: frozenset[Any]) -> bool:
        """Check EXACT match of modifier groups (ctrl, alt, shift)."""
        from pynput.keyboard import Key
        for key_names in self._MODIFIER_MAP.values():
            group = frozenset(
                getattr(Key, n) for n in key_names if hasattr(Key, n)
            )
            group_required = bool(required_mods & group)
            group_held = bool(self._held_mods & group)
            if group_required != group_held:
                return False
        return True

    @classmethod
    def _parse_combo(cls, combo: str) -> tuple[Any, frozenset[Any]]:
        """Parse "ctrl+Insert" into (Key.insert, frozenset({Key.ctrl_l, Key.ctrl_r}))."""
        from pynput.keyboard import Key
        parts = [p.strip() for p in combo.split("+")]
        modifier_strings = parts[:-1]
        key_string = parts[-1]
        mods: set[Any] = set()
        for mod_str in modifier_strings:
            normalized = mod_str.lower()
            if normalized not in cls._MODIFIER_MAP:
                raise RedictumError(f"Unknown modifier: '{mod_str}'")
            for attr in cls._MODIFIER_MAP[normalized]:
                if hasattr(Key, attr):
                    mods.add(getattr(Key, attr))
        trigger = cls._parse_key(key_string)
        return trigger, frozenset(mods)

    @classmethod
    def _parse_key(cls, hotkey: str) -> Any:
        """Parse a hotkey string into a pynput Key or KeyCode.

        Supports: "Insert", "F1"-"F20", single characters ("a", "b"), etc.
        """
        from pynput.keyboard import Key, KeyCode

        normalized = hotkey.strip().lower()

        # Function keys: f1-f20
        if normalized.startswith("f") and normalized[1:].isdigit():
            attr = normalized
            if hasattr(Key, attr):
                return getattr(Key, attr)

        # Named keys
        if normalized in cls._KEY_MAP:
            return getattr(Key, cls._KEY_MAP[normalized])

        # Single character
        if len(hotkey.strip()) == 1:
            return KeyCode.from_char(hotkey.strip())

        raise RedictumError(f"Unknown hotkey: '{hotkey}'")


class Housekeeping:
    """Rotate old audio and transcript files."""

    def __init__(
        self,
        audio_dir: Path,
        transcripts_dir: Path,
        logs_dir: Path,
        storage_cfg: dict[str, Any],
    ) -> None:
        self._audio_dir = audio_dir
        self._transcripts_dir = transcripts_dir
        self._logs_dir = logs_dir
        self._audio_max = storage_cfg.get("audio_max_files", 50)
        self._transcripts_max = storage_cfg.get("transcripts_max_files", 50)
        self._logs_max = storage_cfg.get("logs_max_files", 50)

    def _rotate_dir(self, directory: Path, pattern: str,
                    max_files: int, label: str) -> int:
        """Glob *pattern* in *directory*, sort by mtime, rotate excess."""
        files = sorted(directory.glob(pattern), key=lambda p: p.stat().st_mtime)
        return self._rotate(files, max_files, label)

    def rotate_audio(self) -> int:
        """Remove oldest audio files exceeding the limit."""
        return self._rotate_dir(self._audio_dir, "*.wav",
                                self._audio_max, "Audio")

    def rotate_transcripts(self) -> int:
        """Remove oldest daily transcript files exceeding the limit."""
        return self._rotate_dir(self._transcripts_dir, "*.txt",
                                self._transcripts_max, "Transcript")

    def rotate_logs(self) -> int:
        """Remove oldest session log files exceeding the limit."""
        return self._rotate_dir(self._logs_dir, "*.log",
                                self._logs_max, "Log")

    @staticmethod
    def _rotate(files: list[Path], max_files: int, label: str) -> int:
        """Remove oldest files exceeding *max_files*."""
        excess = len(files) - max_files
        if excess <= 0:
            return 0
        removed = 0
        for path in files[:excess]:
            try:
                path.unlink()
                removed += 1
            except OSError:
                logging.warning("Failed to remove %s", path)
        if removed:
            logging.info("%s rotation: removed %d old file(s)", label, removed)
        return removed


def _log_transcript(transcripts_dir: Path, text: str) -> None:
    """Append transcript to a daily file transcripts/YYYY-MM-DD.txt."""
    date_str = datetime.now().strftime("%Y-%m-%d")
    log_file = transcripts_dir / f"{date_str}.txt"
    timestamp = datetime.now().strftime("%H:%M:%S")
    with open(log_file, "a", encoding="utf-8") as f:
        f.write(f"[{timestamp}] {text}\n")


# ---------------------------------------------------------------------------
# RedictumApp — orchestrator
# ---------------------------------------------------------------------------

class RedictumApp:
    """Main application orchestrator that wires all components together."""

    def __init__(self, script_dir: Path, overrides: list[str] | None = None) -> None:
        self._script_dir = script_dir
        self._config_mgr = ConfigManager(script_dir)
        self._dir_mgr = DirectoryManager(script_dir)
        self._pid_path = script_dir / PID_FILENAME
        self._log_path = self._make_log_path()
        self._state_mgr = StateManager(script_dir)
        self._config: dict[str, Any] = {}
        self._overrides = overrides or []

    def _make_log_path(self, label: str = "") -> Path:
        """Build a log file path with optional label in the name.

        Returns:
            ``logs/redictum_YYYYMMDD_HHMMSS.log`` or
            ``logs/redictum_<label>_YYYYMMDD_HHMMSS.log``.
        """
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        name = f"redictum_{label}_{ts}.log" if label else f"redictum_{ts}.log"
        return self._script_dir / "logs" / name

    def _load_config(self) -> dict[str, Any]:
        """Load config and apply CLI overrides (if any)."""
        self._config_mgr.sync()
        config = self._config_mgr.load()
        if self._overrides:
            _apply_overrides(config, self._overrides)
        return config

    def _is_initialized(self) -> bool:
        """Check if state contains an ``initialized_at`` timestamp."""
        return bool(self._state_mgr.get("initialized_at"))

    def _mark_initialized(self) -> None:
        """Record initialization timestamp and version in state."""
        state = self._state_mgr.load()
        state["initialized_at"] = datetime.now().isoformat()
        state["version"] = VERSION
        self._state_mgr.save(state)

    def init(self) -> dict[str, Any]:
        """Initialize config, directories, and run diagnostics.

        Returns:
            Loaded configuration dictionary.

        Raises:
            RedictumError: If a critical dependency is missing.
        """
        config = self._load_config()
        self._dir_mgr.ensure()
        diag = Diagnostics(config, self._config_mgr, self._state_mgr)
        diag.run_stage1()
        diag.run_stage2()
        # Early exit if core APT/pip deps still missing after stage 2
        missing_core: list[str] = []
        for name in APT_PACKAGES:
            if not shutil.which(name):
                missing_core.append(name)
        for import_name, pip_name in PIP_PACKAGES.items():
            try:
                __import__(import_name)
            except ImportError:
                missing_core.append(pip_name)
        if missing_core:
            logging.error("Setup incomplete: missing %s", missing_core)
            raise RedictumError(
                "Setup incomplete. Missing critical dependencies:\n"
                + "".join(f"  \u2022 {m}\n" for m in missing_core)
                + "Run again to install them."
            )
        diag.run_optional()
        # Reload config — run_optional() may have updated settings on disk
        config = self._load_config()
        diag = Diagnostics(config, self._config_mgr, self._state_mgr)
        diag.check_whisper()
        # Reload config — check_whisper() may have updated paths on disk
        config = self._load_config()
        # Verify all runtime deps are satisfied
        missing = self._collect_missing_deps(config)
        if missing:
            logging.error("Setup incomplete: missing %s", missing)
            raise RedictumError(
                "Setup incomplete. Missing dependencies:\n"
                + "".join(f"  \u2022 {m}\n" for m in missing)
                + "Run again to install them."
            )
        self._mark_initialized()
        return config

    def init_quick(self) -> dict[str, Any]:
        """Load config and ensure directories without running diagnostics.

        Returns:
            Loaded configuration dictionary.
        """
        config = self._load_config()
        self._dir_mgr.ensure()
        return config

    def _collect_missing_deps(self, config: dict[str, Any]) -> list[str]:
        """Return names of missing runtime dependencies."""
        missing: list[str] = []
        for name in APT_PACKAGES:
            if not shutil.which(name):
                missing.append(name)
        for import_name, pip_name in PIP_PACKAGES.items():
            try:
                __import__(import_name)
            except ImportError:
                missing.append(pip_name)
        dep = config.get("dependency", {})
        cli_path = dep.get("whisper_cli", "")
        model_path = dep.get("whisper_model", "")
        if not cli_path or not Path(cli_path).exists():
            missing.append("whisper.cpp")
        if not model_path or not Path(model_path).exists():
            missing.append("whisper model")
        return missing

    def _deps_ok(self, config: dict[str, Any]) -> bool:
        """Silently check that all critical dependencies are present."""
        # Stage 1: critical environment
        if sys.version_info < (3, 10):  # noqa: UP036
            return False
        if sys.platform != "linux":
            return False
        if not shutil.which("arecord"):
            return False
        if not os.environ.get("DISPLAY"):
            return False
        # Audio device must be resolved (not "auto")
        device = config.get("audio", {}).get("recording_device", "auto")
        if device == "auto":
            return False
        # Stage 2 + whisper
        return not self._collect_missing_deps(config)

    def _check_optional_mismatch(self, config: dict[str, Any]) -> bool:
        """Return True if any optional feature is enabled but its tool is missing."""
        notif = config.get("notification", {})
        sound_keys = ("sound_signal_start", "sound_signal_processing",
                      "sound_signal_done", "sound_signal_error")
        if any(notif.get(k, True) for k in sound_keys) and not shutil.which("paplay"):
            return True
        if config.get("audio", {}).get("recording_normalize", True) and not shutil.which("ffmpeg"):
            return True
        if config.get("clipboard", {}).get("paste_auto", True) and not shutil.which("xdotool"):
            return True
        return False

    def _print_banner(self, ready: bool = False) -> None:
        """Print compact startup banner with hotkeys and language info."""
        if ready:
            _rprint("[bold green]Redictum Terminal — ready![/bold green]")
        else:
            _rprint("[bold]Redictum Terminal[/bold]")

        # Resolve hotkey names from config
        input_cfg = self._config.get("input", {})
        key = input_cfg.get("hotkey_key", "Insert")
        translate_key = input_cfg.get("hotkey_translate_key", "")
        parts = [f"{key} (transcribe)"]
        if translate_key:
            parts.append(f"{translate_key} (translate)")
        _rprint(f"Listening: {', '.join(parts)}")

        # Resolve language
        dep_cfg = self._config.get("dependency", {})
        language = dep_cfg.get("whisper_language", "auto")
        if language == "auto":
            detected = _detect_language()
            _rprint(f"Language: {detected} (auto)")
        else:
            _rprint(f"Language: {language}")

        if self._overrides:
            _rprint(f"[yellow]Overrides: {len(self._overrides)}[/yellow]")

        _rprint("\nPress Ctrl+C to stop.")

    def _show_config_hint(self) -> None:
        """Show config file location and examples after first run."""
        if self._state_mgr.get("config_hint_shown"):
            return
        _rprint(f"\n[bold]Configuration:[/bold] {self._config_mgr.path}")
        _rprint("  Examples:")
        _rprint('    \u2022 Change hotkey:   [cyan]hotkey_key = "F12"[/cyan]'
               '          (default: Insert)')
        _rprint('    \u2022 Change language: [cyan]whisper_language = "en"[/cyan]'
               '      (default: auto)')
        self._state_mgr.set("config_hint_shown", True)

    def _fix_optional_mismatch(self) -> None:
        """Re-check optional deps if config says enabled but tool is gone."""
        if self._check_optional_mismatch(self._config):
            diag = Diagnostics(self._config, self._config_mgr, self._state_mgr)
            diag.run_optional()
            self._config = self._load_config()

    def _record_run_timestamp(self) -> None:
        """Persist last-run timestamp and version in state."""
        state = self._state_mgr.load()
        state["last_run"] = datetime.now().isoformat()
        state["version"] = VERSION
        self._state_mgr.save(state)

    def run_interactive(self) -> int:
        """Run in interactive (foreground) mode.

        Returns:
            Exit code.
        """
        setup_logging(self._log_path, verbose=(_verbosity > 0))
        _log_system_info()

        first_run = not self._is_initialized()
        if not first_run:
            self._config = self.init_quick()
            if self._deps_ok(self._config):
                self._fix_optional_mismatch()
                ready = False
            else:
                self._config = self.init()
                ready = True
        else:
            self._config = self.init()
            ready = True

        if first_run:
            self._first_run_language_check(self._config)
            self._show_config_hint()

        self._record_run_timestamp()

        stop_event = threading.Event()

        def handle_signal(signum: int, frame: Any) -> None:
            stop_event.set()

        signal.signal(signal.SIGINT, handle_signal)
        signal.signal(signal.SIGTERM, handle_signal)

        self._print_banner(ready=ready)
        logging.info("Interactive mode started (PID %d)", os.getpid())
        logging.info("Starting main loop...")
        self._main_loop(stop_event)
        logging.info("Interactive mode stopped.")
        return EXIT_OK

    def run_start(self) -> int:
        """Start the daemon.

        Returns:
            Exit code.
        """
        setup_logging(self._log_path, verbose=(_verbosity > 0))
        _log_system_info()

        if not self._is_initialized():
            raise RedictumError(
                "Redictum is not initialized. "
                "Run Redictum in interactive mode first to complete setup."
            )

        self._config = self.init_quick()
        if self._deps_ok(self._config):
            self._fix_optional_mismatch()
        else:
            self._config = self.init()

        self._record_run_timestamp()

        daemon = Daemon(self._pid_path, self._log_path)
        _rprint("[bold]Redictum Terminal — daemon started.[/bold]")

        def target() -> None:
            self._main_loop(daemon.stop_event)

        daemon.start(target=target)
        return EXIT_OK

    def run_stop(self) -> int:
        """Stop the daemon.

        Returns:
            Exit code.
        """
        daemon = Daemon(self._pid_path, self._log_path)
        daemon.stop()
        _rprint("[green]Daemon stopped.[/green]")
        return EXIT_OK

    def run_status(self) -> int:
        """Print daemon status.

        Returns:
            Exit code.
        """
        daemon = Daemon(self._pid_path, self._log_path)
        pid = daemon.status()
        if pid is not None:
            _rprint(f"[green]Daemon is running[/green] (PID {pid})")
        else:
            _rprint("[yellow]Daemon is not running.[/yellow]")
        return EXIT_OK

    def run_setup(self) -> int:
        """Re-run optional dependency setup (force-check all features).

        Returns:
            Exit code.
        """
        self._log_path = self._make_log_path("setup")
        setup_logging(self._log_path, verbose=(_verbosity > 0))
        logging.info("Subcommand: setup")
        self._config = self._load_config()
        self._dir_mgr.ensure()
        _rprint("[bold]Redictum \u2014 Dependency Setup[/bold]")
        diag = Diagnostics(self._config, self._config_mgr, self._state_mgr)
        diag.run_optional(force=True)
        self._config = self._load_config()
        _rprint("\n[green]Setup complete.[/green]")
        logging.info("Setup complete")
        return EXIT_OK

    def run_whisper(self) -> int:
        """Setup whisper.cpp: install, check, or reconfigure.

        Returns:
            Exit code.
        """
        self._log_path = self._make_log_path("whisper")
        setup_logging(self._log_path, verbose=(_verbosity > 0))
        logging.info("Subcommand: whisper")
        self._config = self._load_config()
        self._dir_mgr.ensure()
        installer = WhisperInstaller(self._config_mgr, self._state_mgr)
        installer.install()
        logging.info("Whisper subcommand complete")
        return EXIT_OK

    @staticmethod
    def _display_language(lang: str, prompt: str) -> None:
        """Print the chosen language settings."""
        if lang == "auto":
            _rprint("\n  whisper_language = [cyan]auto[/cyan]")
            _rprint("  whisper_prompt   = [cyan]auto[/cyan]")
        else:
            lang_name = LANGUAGE_NAMES.get(lang, lang)
            short = prompt[:60] + "..." if len(prompt) > 60 else prompt
            _rprint(f"\n  whisper_language = [cyan]{lang}[/cyan] ({lang_name})")
            _rprint(f"  whisper_prompt   = {short}")

    def _confirm_and_save_language(self, lang: str, prompt: str) -> bool:
        """Ask to save and persist language settings.  Return True if saved."""
        if not _confirm("\nSave to config?", default=True):
            return False
        self._config_mgr.update({
            "whisper_language": lang,
            "whisper_prompt": prompt,
        })
        _rprint("[green]Language settings saved.[/green]")
        return True

    def run_language(self) -> int:
        """Change transcription language via interactive wizard.

        Returns:
            Exit code.
        """
        self._log_path = self._make_log_path("language")
        setup_logging(self._log_path, verbose=(_verbosity > 0))
        logging.info("Subcommand: language")
        self._config = self._load_config()

        if _verbosity < 0:
            # Quiet mode: set auto without wizard
            self._config_mgr.update({
                "whisper_language": "auto",
                "whisper_prompt": "auto",
            })
            logging.info("Language set to auto (quiet mode)")
            return EXIT_OK

        detected = _show_language_status(self._config)

        if not _confirm("Change language?", default=True):
            return EXIT_OK

        result = _language_wizard(detected)
        if result is None:
            return EXIT_OK

        lang, prompt = result
        self._display_language(lang, prompt)

        # Check daemon
        daemon = Daemon(self._pid_path, self._log_path)
        if daemon.status() is not None:
            _rprint("\n[yellow]Daemon is running. Restart it for changes to take effect.[/yellow]")

        if not self._confirm_and_save_language(lang, prompt):
            return EXIT_OK

        logging.info("Language saved: %s", lang)
        return EXIT_OK

    # -- Self-update ----------------------------------------------------------

    def _fetch_latest_version(self) -> str:
        """Query GitHub Releases API for the latest version tag.

        Returns:
            Version string without leading ``v`` (e.g. ``1.4.0``).

        Raises:
            RedictumError: On network/parse failure.
        """
        _rprint(f"  Update: checking {GITHUB_API_LATEST}", level=1)
        timeout = UPDATE_API_TIMEOUT
        if shutil.which("curl"):
            cmd = ["curl", "-fsSL", "-m", str(timeout), GITHUB_API_LATEST]
        elif shutil.which("wget"):
            cmd = ["wget", "-q", "-O", "-", f"--timeout={timeout}", GITHUB_API_LATEST]
        else:
            raise RedictumError("Neither curl nor wget found. Cannot check for updates.")

        try:
            result = subprocess.run(
                cmd, capture_output=True, text=True,
                timeout=timeout + 5,
            )
        except subprocess.TimeoutExpired as exc:
            raise RedictumError("Timed out checking for updates. Try again later.") from exc

        if result.returncode != 0:
            raise RedictumError(
                f"Failed to check for updates (exit {result.returncode}). "
                "Check your internet connection."
            )

        import json as _json
        try:
            data = _json.loads(result.stdout)
            tag = data["tag_name"]
        except (ValueError, KeyError) as exc:
            raise RedictumError("Unexpected response from GitHub API.") from exc

        return tag.lstrip("v")

    def _download_to_file(self, url: str, dest: Path, timeout: int) -> None:
        """Download *url* to *dest* file using curl or wget.

        Raises:
            RedictumError: On download failure.
        """
        _rprint(f"  Download: {url}", level=1)
        dest_str = str(dest)
        if shutil.which("curl"):
            cmd = ["curl", "-fsSL", "-m", str(timeout), "-o", dest_str, url]
        elif shutil.which("wget"):
            cmd = ["wget", "-q", "-O", dest_str, f"--timeout={timeout}", url]
        else:
            raise RedictumError("Neither curl nor wget found. Cannot download update.")

        try:
            result = subprocess.run(
                cmd, capture_output=True, text=True,
                timeout=timeout + 5,
            )
        except subprocess.TimeoutExpired as exc:
            raise RedictumError("Download timed out. Try again later.") from exc

        if result.returncode != 0 or not dest.exists():
            raise RedictumError(f"Failed to download {url}")

    def run_update(self) -> int:
        """Check for updates and replace the script in-place.

        Returns:
            Exit code.
        """
        _rprint(f"  Current version: [cyan]{VERSION}[/cyan]")
        _rprint("  Checking for updates...")

        try:
            latest = self._fetch_latest_version()
        except RedictumError:
            raise

        cmp = _compare_versions(VERSION, latest)
        if cmp >= 0:
            _rprint("  Already up to date.")
            return EXIT_OK

        _rprint(f"  New version available: [green]{latest}[/green]")
        if not _confirm("  Update?", default=True):
            return EXIT_OK

        # Check daemon
        daemon = Daemon(self._pid_path, self._log_path)
        if daemon.status() is not None:
            _rprint("[red]  Daemon is running. Stop it first: ./redictum stop[/red]")
            return EXIT_ERROR

        tag = f"v{latest}"
        hash_url = f"{GITHUB_RELEASE_BASE}/{tag}/redictum.sha256"
        script_url = f"{GITHUB_RELEASE_BASE}/{tag}/redictum"

        tmp_hash_fd, tmp_hash_path = tempfile.mkstemp(prefix="redictum_hash_")
        tmp_script_fd, tmp_script_path = tempfile.mkstemp(prefix="redictum_update_")
        os.close(tmp_hash_fd)
        os.close(tmp_script_fd)
        tmp_hash = Path(tmp_hash_path)
        tmp_script = Path(tmp_script_path)

        try:
            _rprint("  Downloading...")
            self._download_to_file(hash_url, tmp_hash, UPDATE_DL_TIMEOUT)
            expected_hash = tmp_hash.read_text().strip().split()[0]

            self._download_to_file(script_url, tmp_script, UPDATE_DL_TIMEOUT)

            _rprint("  Verifying checksum...")
            actual_hash = hashlib.sha256(tmp_script.read_bytes()).hexdigest()
            _rprint(f"  Checksum OK: {actual_hash[:16]}...", level=1)
            if actual_hash != expected_hash:
                _rprint("[red]  Checksum mismatch — download may be corrupted. Aborting.[/red]")
                return EXIT_ERROR

            # Backup and replace
            script_path = Path(__file__).resolve()
            backup_path = script_path.with_suffix(".bak")
            shutil.copy2(str(script_path), str(backup_path))
            shutil.copy2(str(tmp_script), str(script_path))
            os.chmod(str(script_path), 0o755)

            _rprint(f"  [green]Updated: {VERSION} → {latest}[/green]")
            _rprint(f"  Backup saved: {backup_path}")
            return EXIT_OK
        finally:
            tmp_hash.unlink(missing_ok=True)
            tmp_script.unlink(missing_ok=True)

    def _first_run_language_check(self, config: dict[str, Any]) -> None:  # pragma: no cover
        """Offer to change language during first run.

        Args:
            config: Loaded configuration dictionary.
        """
        detected = _detect_language()
        if detected:
            name = LANGUAGE_NAMES.get(detected, detected)
            _rprint(f"\nLanguage detected: [cyan]{detected}[/cyan] ({name}) from system locale.")
        else:
            _rprint("\nLanguage: could not detect from system locale (will use auto).")

        if not _confirm("Change language?", default=False):
            return

        result = _language_wizard(detected)
        if result is None:
            return

        lang, prompt = result
        self._display_language(lang, prompt)
        self._confirm_and_save_language(lang, prompt)

    def _main_loop(self, stop_event: threading.Event) -> None:
        """Main loop: push-to-talk → record → normalize → transcribe → paste."""
        cfg = self._config
        audio_dir = self._script_dir / "audio"
        self._transcripts_dir = self._script_dir / "transcripts"

        # Unpack config sections (2-level: section → key)
        dep = cfg["dependency"]
        self._audio_cfg = cfg["audio"]
        self._clip_cfg = cfg["clipboard"]
        self._sound_cfg = cfg["notification"]

        # Resolve language: "auto" -> detect from system locale
        language = dep.get("whisper_language", "auto")
        if language == "auto":
            language = _detect_language()
            logging.info("Language auto-detected from locale: %r", language)

        # Verbose config dump
        if _verbosity > 0:
            _rprint(f"  Config: language={language}", level=1)
            _rprint(f"  Config: device={self._audio_cfg['recording_device']}", level=1)
            normalize = self._audio_cfg.get('recording_normalize', True)
            _rprint(f"  Config: normalize={normalize}", level=1)
            _rprint(f"  Config: hotkey={cfg['input']['hotkey_key']}", level=1)

        # Build pipeline components
        self._recorder = AudioRecorder(audio_dir, self._audio_cfg["recording_device"])
        self._processor = AudioProcessor()
        self._transcriber = Transcriber(
            dep["whisper_cli"],
            dep["whisper_model"],
            language,
            prompt=dep.get("whisper_prompt", ""),
            timeout=dep.get("whisper_timeout", 120),
        )
        self._clipboard = ClipboardManager()
        self._notifier = SoundNotifier(volume=self._sound_cfg.get("sound_signal_volume", 30))
        if self._audio_cfg.get("recording_volume_reduce", True):
            self._volume_ctl: VolumeController | None = VolumeController(
                self._audio_cfg.get("recording_volume_level", 30),
            )
        else:
            self._volume_ctl = None
        logs_dir = self._log_path.parent
        self._housekeeper = Housekeeping(
            audio_dir, self._transcripts_dir, logs_dir, cfg["storage"],
        )
        listener = HotkeyListener(
            cfg["input"]["hotkey_key"], cfg["input"]["hotkey_hold_delay"],
            translate_key=cfg["input"].get("hotkey_translate_key", ""),
        )

        # State machine
        # Threading model: all pipeline components above are created here (main
        # thread) and treated as read-only by _on_hold/_on_release/_run_pipeline
        # callbacks which run in pynput and daemon threads.  Only _state and
        # _current_mode are mutated concurrently — always under _state_lock.
        # The state machine (IDLE → RECORDING → PROCESSING → IDLE) ensures
        # that recorder.start() and recorder.stop() never overlap.
        self._state = STATE_IDLE
        self._state_lock = threading.Lock()
        self._pipeline_done = threading.Event()
        self._pipeline_done.set()  # no pipeline running initially
        self._current_mode = "transcribe"

        # Start listening
        listener.start(self._on_hold, self._on_release)

        # Wait for shutdown signal
        stop_event.wait()

        # Graceful shutdown
        self._graceful_shutdown(listener)

    def _on_hold(self, mode: str) -> None:
        """Callback: hotkey held — start recording."""
        with self._state_lock:
            if self._state != STATE_IDLE:
                return
            self._state = STATE_RECORDING
            self._current_mode = mode
        try:
            self._recorder.start()
        except Exception:
            with self._state_lock:
                self._state = STATE_IDLE
            logging.exception("Failed to start recording")
            self._notifier.play_error()
            _rprint("[red]\u2717 Recording failed[/red]")
            return
        if self._sound_cfg.get("sound_signal_start", True):
            self._notifier.play_start()
        if self._volume_ctl:
            time.sleep(0.15)
            self._volume_ctl.reduce()
        _rprint("")
        _rprint("[bold]\u25cf Recording...[/bold]")
        _rprint(f"  Recording: device={self._audio_cfg['recording_device']}", level=1)
        logging.info("Recording started (mode: %s)", mode)

    def _on_release(self, mode: str) -> None:
        """Callback: hotkey released — launch processing pipeline."""
        with self._state_lock:
            if self._state != STATE_RECORDING:
                return
            self._state = STATE_PROCESSING
            captured_mode = self._current_mode
        self._pipeline_done.clear()
        thread = threading.Thread(
            target=self._run_pipeline, args=(captured_mode,), daemon=True,
        )
        thread.start()

    def _run_pipeline(self, mode: str) -> None:
        """Record → silence check → normalize → transcribe → paste."""
        try:
            audio_path = self._recorder.stop()
            # Restore volume ASAP so user hears audio during processing;
            # the finally block below is a safety net (restore is idempotent).
            if self._volume_ctl:
                self._volume_ctl.restore()
            if self._sound_cfg.get("sound_signal_processing", False):
                self._notifier.play_processing()
            if audio_path is None:
                logging.warning("Recording produced no audio")
                if self._sound_cfg.get("sound_signal_error", True):
                    self._notifier.play_error()
                _rprint("[red]\u2717 Empty recording, skipped[/red]")
                return

            _rprint("[dim]\u27f3 Processing...[/dim]")
            _rprint(f"  Audio: {audio_path.name} ({audio_path.stat().st_size} bytes)", level=1)

            # Silence detection (before normalize — loudnorm amplifies noise)
            if self._audio_cfg.get("recording_silence_detection", True):
                threshold = self._audio_cfg.get(
                    "recording_silence_threshold", SILENCE_RMS_THRESHOLD,
                )
                if not self._processor.has_speech(audio_path, threshold=threshold):
                    logging.info("Silence detected, skipping transcription")
                    _rprint("[dim]\u2014 Silence, skipped[/dim]")
                    return

            # Normalize
            if self._audio_cfg.get("recording_normalize", True):
                try:
                    audio_path = self._processor.normalize(audio_path)
                except RedictumError:
                    logging.exception("Normalization failed, using raw audio")

            # Transcribe
            text = self._transcriber.transcribe(
                audio_path,
                translate=(mode == "translate"),
            )
            if not text:
                logging.info("Transcription returned empty text")
                _rprint("[dim]\u2014 Empty transcription[/dim]")
                return

            logging.info("Transcribed (mode: %s): %d chars", mode, len(text))

            # Apply prefix/postfix
            prefix = self._clip_cfg.get("paste_prefix", "")
            postfix = self._clip_cfg.get("paste_postfix", "")
            final_text = f"{prefix}{text}{postfix}"

            # Log transcript (must not block paste on failure)
            try:
                _log_transcript(self._transcripts_dir, final_text)
            except OSError:
                logging.exception("Failed to write transcript log")

            # Clipboard: save → copy → paste → restore
            if self._clip_cfg.get("paste_auto", True):
                saved = self._clipboard.save()
                self._clipboard.copy(final_text)
                self._clipboard.paste()
                # Restore previous clipboard after a short delay
                time.sleep(self._clip_cfg.get("paste_restore_delay", 0.3))
                if saved:
                    self._clipboard.restore(saved)
            else:
                self._clipboard.copy(final_text)

            _rprint(f"[green]\u2713[/green] \"{final_text.strip()}\"")
            _rprint(f"  Transcribed: {mode}, {len(text)} chars", level=1)

            if self._sound_cfg.get("sound_signal_done", True):
                self._notifier.play_stop()
            self._housekeeper.rotate_audio()
            self._housekeeper.rotate_transcripts()
            self._housekeeper.rotate_logs()
            logging.info("Pipeline complete, state -> idle")
        except RedictumError as exc:
            logging.exception("Pipeline error")
            if self._sound_cfg.get("sound_signal_error", True):
                self._notifier.play_error()
            _rprint(f"[red]\u2717 {exc}[/red]")
        except Exception:
            logging.exception("Unexpected pipeline error")
            if self._sound_cfg.get("sound_signal_error", True):
                self._notifier.play_error()
            _rprint("[red]\u2717 Unexpected error[/red]")
        finally:
            if self._volume_ctl:
                self._volume_ctl.restore()
            with self._state_lock:
                self._state = STATE_IDLE
            self._pipeline_done.set()

    def _graceful_shutdown(self, listener: HotkeyListener) -> None:
        """Stop listener and wait for any in-progress pipeline to finish."""
        listener.stop()
        if self._notifier:
            self._notifier.cleanup()
        with self._state_lock:
            current = self._state
        if current == STATE_RECORDING:
            self._recorder.cancel()
            if self._volume_ctl:
                self._volume_ctl.restore()
            logging.info("Cancelled recording during shutdown")
        elif current == STATE_PROCESSING:
            logging.info("Waiting for processing to finish...")
            self._pipeline_done.wait(timeout=30)
        logging.info("Main loop stopped")


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------

def _apply_overrides(config: dict[str, Any], overrides: list[str]) -> dict[str, Any]:
    """Apply ``--set section.key=value`` CLI overrides to config.

    Validates that the key exists in DEFAULT_CONFIG and that the value
    can be parsed to the expected type.

    Args:
        config: Already loaded config dict (defaults + INI).
        overrides: List of ``"section.key=value"`` strings from CLI.

    Returns:
        Config with overrides applied (modified in place).

    Raises:
        RedictumError: On unknown key, missing ``=``, or type mismatch.
    """
    for item in overrides:
        if "=" not in item:
            raise RedictumError(
                f'Invalid --set format: "{item}" (expected section.key=value)'
            )
        dotted_key, _, raw_value = item.partition("=")
        parts = dotted_key.split(".")
        if len(parts) != 2:
            raise RedictumError(
                f'Invalid key: "{dotted_key}" (expected section.key, '
                f"e.g. dependency.whisper_language)"
            )
        section, key = parts

        # Validate key exists in defaults
        if section not in DEFAULT_CONFIG:
            _all_sections = ", ".join(sorted(DEFAULT_CONFIG))
            raise RedictumError(
                f'Unknown section: "{section}"\n'
                f"Available sections: {_all_sections}"
            )
        if key not in DEFAULT_CONFIG[section]:
            _all_keys = ", ".join(sorted(DEFAULT_CONFIG[section]))
            raise RedictumError(
                f'Unknown key: "{key}" in [{section}]\n'
                f"Available keys: {_all_keys}"
            )

        # Parse value to the expected type
        default_val = DEFAULT_CONFIG[section][key]
        try:
            if isinstance(default_val, bool):
                if raw_value.lower() in ("true", "yes", "1", "on"):
                    parsed: Any = True
                elif raw_value.lower() in ("false", "no", "0", "off"):
                    parsed = False
                else:
                    raise ValueError(f"expected true/false, got {raw_value!r}")
            elif isinstance(default_val, int):
                parsed = int(raw_value)
            elif isinstance(default_val, float):
                parsed = float(raw_value)
            else:
                parsed = ConfigManager._strip_quotes(raw_value)
        except (ValueError, TypeError) as exc:
            raise RedictumError(
                f'Invalid value for "{dotted_key}": {exc}'
            ) from exc

        # Apply override
        if section not in config:
            config[section] = {}
        config[section][key] = parsed
        logging.info("Config override: %s.%s = %r", section, key, parsed)

    return config


def build_parser() -> argparse.ArgumentParser:
    """Build and return the argument parser.

    Returns:
        Configured ArgumentParser instance.
    """
    parser = argparse.ArgumentParser(
        prog="redictum",
        description="Redictum Terminal — voice-to-text CLI for Linux.",
    )
    parser.add_argument(
        "--version",
        action="version",
        version=f"redictum {VERSION}",
    )
    parser.add_argument(
        "--reset-config",
        action="store_true",
        help="Recreate config.ini with default values",
    )
    parser.add_argument(
        "--set",
        action="append",
        dest="overrides",
        metavar="section.key=value",
        help="Override a config value for this run (repeatable)",
    )
    verbosity = parser.add_mutually_exclusive_group()
    verbosity.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Verbose output (show diagnostics)",
    )
    verbosity.add_argument(
        "-q", "--quiet",
        action="store_true",
        help="Quiet mode (suppress output, auto-answer with defaults)",
    )
    sub = parser.add_subparsers(dest="command")

    sub.add_parser("start", help="Start the daemon")
    sub.add_parser("stop", help="Stop the daemon")
    sub.add_parser("status", help="Show daemon status")
    sub.add_parser("setup", help="Re-run optional dependency setup")
    sub.add_parser("whisper", help="Setup whisper.cpp (install, check, reconfigure)")
    sub.add_parser("language", help="Change transcription language")
    sub.add_parser("update", help="Update to the latest version")

    return parser


def main() -> int:
    """Entry point for Redictum Terminal.

    Returns:
        Exit code (0 = success, 1 = error).
    """
    parser = build_parser()
    args = parser.parse_args()

    global _verbosity
    if args.quiet:
        _verbosity = -1
    elif args.verbose:
        _verbosity = 1

    script_dir = Path(__file__).resolve().parent
    app = RedictumApp(script_dir, overrides=args.overrides)

    if args.reset_config:
        if args.command is not None:
            print("Error: --reset-config can only be used in interactive"
                  " mode (without subcommand)", file=sys.stderr)
            return EXIT_ERROR
        config_path = script_dir / "config.ini"
        if config_path.exists():
            config_path.unlink()
        state_path = script_dir / STATE_FILENAME
        if state_path.exists():
            state_path.unlink()

    try:
        if args.command is None:
            return app.run_interactive()
        if args.command == "start":
            return app.run_start()
        if args.command == "stop":
            return app.run_stop()
        if args.command == "status":
            return app.run_status()
        if args.command == "setup":
            return app.run_setup()
        if args.command == "whisper":
            return app.run_whisper()
        if args.command == "language":
            return app.run_language()
        if args.command == "update":
            return app.run_update()
    except RedictumError as exc:
        print(f"Error: {exc}", file=sys.stderr)
        return EXIT_ERROR
    except KeyboardInterrupt:
        return EXIT_OK
    except Exception:
        logging.exception("Fatal error")
        _rprint("[red]Fatal error. Check logs for details.[/red]")
        return EXIT_ERROR

    return EXIT_OK


# ---------------------------------------------------------------------------
# Tone synthesis (used by SoundNotifier)
# ---------------------------------------------------------------------------
# Each tone is a list of float samples in [-1, 1] range.  Synthesis uses
# additive sine waves with exponential envelopes to produce short, distinct
# notification sounds.  The helpers below are intentionally compact — they
# run once at startup and the output is cached as WAV files.

def _generate_tones() -> dict[str, list[float]]:
    """Return ``{name: samples}`` for all notification sounds."""
    sr = 44100
    _s = lambda f, t: math.sin(2 * math.pi * f * t)  # noqa: E731
    _e = math.exp                                      # noqa: E731

    def _beep(freq: float) -> list[float]:
        """Single short beep at *freq* Hz (used by 'start')."""
        n = int(sr * 0.04)
        return [(1 - _e(-800 * t)) * _e(-20 * t) * _s(freq, t)
                for i in range(n) for t in [i / sr]]

    gap = [0.0] * int(sr * 0.03)

    return {
        # Three ascending beeps — recording started
        "start": _beep(1000) + gap + _beep(1300) + gap + _beep(1600),

        # Metallic tick with inharmonic overtones — transcription started
        "processing": [
            _e(-25 * t) * (1 - _e(-800 * t))
            * (0.5 * _s(900, t) + 0.3 * _s(2160, t) + 0.2 * _s(3690, t))
            for i in range(int(sr * 0.08)) for t in [i / sr]
        ],

        # Glass tap with shimmering harmonics — result pasted
        "done": [
            _e(-8 * t) * (1 - _e(-2000 * t))
            * (0.4 * _s(2200, t)
               + 0.3 * _s(3300, t) * _e(-10 * t)
               + 0.2 * _s(5940, t) * _e(-15 * t)
               + 0.1 * _s(9460, t) * _e(-20 * t))
            for i in range(int(sr * 0.2)) for t in [i / sr]
        ],

        # Low buzz with harmonics — error
        "error": [
            (1 - t / 0.25) * (1 - _e(-300 * t))
            * (0.4 * _s(150, t) + 0.3 * _s(300, t)
               + 0.2 * _s(450, t) + 0.1 * _s(750, t))
            for i in range(int(sr * 0.25)) for t in [i / sr]
        ],
    }


if __name__ == "__main__":
    sys.exit(main())
