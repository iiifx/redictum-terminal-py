#!/usr/bin/env python3
"""Redictum Terminal — voice-to-text CLI for Linux."""
from __future__ import annotations

import argparse
import atexit
import json
import logging
import os
import signal
import shutil
import subprocess
import sys
import threading
import time
from pathlib import Path
from typing import Any, Callable

VERSION = "1.0.0-dev"

EXIT_OK = 0
EXIT_ERROR = 1

PID_FILENAME = "redictum.pid"
LOG_FILENAME = "redictum.log"
STOP_TIMEOUT = 3.0

PATH_KEYS = ("whisper_cli", "whisper_model")
REQUIRED_DIRS = ("audio", "transcripts", "logs")

APT_PACKAGES: dict[str, str] = {
    "ffmpeg": "ffmpeg",
    "xclip": "xclip",
    "xdotool": "xdotool",
    "cmake": "cmake",
    "build-essential": "build-essential",
    "git": "git",
}

PIP_PACKAGES: tuple[str, ...] = ("pynput", "rich")

DEFAULT_CONFIG: dict[str, Any] = {
    "whisper_cli": "~/whisper.cpp/build/bin/whisper-cli",
    "whisper_model": "~/whisper.cpp/models/ggml-large-v3-turbo-q5_0.bin",
    "whisper_language": "ru",
    "sample_rate": 16000,
    "channels": 1,
    "normalize_audio": True,
    "hotkey_start": "<ctrl>+<alt>+a",
    "hotkey_stop": "<ctrl>+<alt>+a",
    "auto_paste": True,
    "sound_feedback": True,
    "max_audio_files": 50,
}


class RedictumError(Exception):
    """Base exception for Redictum Terminal errors."""


# ---------------------------------------------------------------------------
# ConfigManager
# ---------------------------------------------------------------------------

class ConfigManager:
    """Manages config.json: generation, loading, merging with defaults.

    Config file lives next to the script. Missing keys are filled from
    DEFAULT_CONFIG; extra keys in the user file are preserved.
    """

    def __init__(self, script_dir: Path) -> None:
        self._path = script_dir / "config.json"

    @property
    def path(self) -> Path:
        """Return the resolved config file path."""
        return self._path

    def load(self) -> dict[str, Any]:
        """Load config from disk or generate a default one.

        Returns:
            Merged configuration dictionary.

        Raises:
            RedictumError: If config.json exists but contains invalid JSON.
        """
        if not self._path.exists():
            self._write_default()
            return self._expand_paths(dict(DEFAULT_CONFIG))

        try:
            raw = self._path.read_text(encoding="utf-8")
            user_config: dict[str, Any] = json.loads(raw)
        except json.JSONDecodeError as exc:
            raise RedictumError(
                f"Invalid JSON in {self._path}: {exc}"
            ) from exc

        merged = dict(DEFAULT_CONFIG)
        merged.update(user_config)
        return self._expand_paths(merged)

    # -- private helpers -----------------------------------------------------

    def _write_default(self) -> None:
        """Write DEFAULT_CONFIG to config.json with pretty formatting."""
        self._path.write_text(
            json.dumps(DEFAULT_CONFIG, indent=4, ensure_ascii=False) + "\n",
            encoding="utf-8",
        )

    @staticmethod
    def _expand_paths(config: dict[str, Any]) -> dict[str, Any]:
        """Expand ``~`` in path-valued keys."""
        for key in PATH_KEYS:
            if key in config and isinstance(config[key], str):
                config[key] = str(Path(config[key]).expanduser())
        return config


# ---------------------------------------------------------------------------
# DirectoryManager
# ---------------------------------------------------------------------------

class DirectoryManager:
    """Creates required working directories next to the script.

    Directories: audio/, transcripts/, logs/.
    """

    def __init__(self, script_dir: Path) -> None:
        self._script_dir = script_dir

    def ensure(self) -> None:
        """Create all required directories if they don't exist."""
        for name in REQUIRED_DIRS:
            (self._script_dir / name).mkdir(exist_ok=True)


# ---------------------------------------------------------------------------
# Stubs
# ---------------------------------------------------------------------------

class Diagnostics:
    """Check external dependencies and offer auto-installation.

    Stage 1 — critical checks (fail fast): Python 3.10+, Linux, PulseAudio,
    ALSA, X11. If any fail, raise RedictumError.

    Stage 2 — installable dependencies (auto-fix): apt and pip packages.
    Offer to install missing ones, user confirms with y/n.

    whisper.cpp — warning only (auto-install in iteration 6).
    """

    def __init__(self, config: dict[str, Any]) -> None:
        self._config = config

    # -- Stage 1: critical checks -------------------------------------------

    def run_stage1(self) -> None:
        """Run all critical checks. Raise RedictumError on first failure."""
        print("Checking dependencies...")
        self._check_python()
        self._check_linux()
        self._check_pulseaudio()
        self._check_alsa()
        self._check_x11()

    def _check_python(self) -> None:
        ver = sys.version_info
        label = f"Python {ver.major}.{ver.minor}.{ver.micro}"
        if ver >= (3, 10):
            print(f"  \u2713 {label}")
        else:
            print(f"  \u2717 {label}")
            raise RedictumError(
                f"Python 3.10+ is required, found {label}."
            )

    def _check_linux(self) -> None:
        if sys.platform == "linux":
            print("  \u2713 Linux")
        else:
            print(f"  \u2717 Linux — detected {sys.platform}")
            raise RedictumError(
                f"Linux is required, detected platform: {sys.platform}."
            )

    def _check_pulseaudio(self) -> None:
        if shutil.which("paplay"):
            print("  \u2713 PulseAudio (paplay)")
        else:
            print("  \u2717 PulseAudio (paplay) \u2014 not found")
            raise RedictumError(
                "PulseAudio (paplay) is required but not found.\n"
                "Install it manually: sudo apt install pulseaudio-utils"
            )

    def _check_alsa(self) -> None:
        if shutil.which("arecord"):
            print("  \u2713 ALSA (arecord)")
        else:
            print("  \u2717 ALSA (arecord) \u2014 not found")
            raise RedictumError(
                "ALSA (arecord) is required but not found.\n"
                "Install it manually: sudo apt install alsa-utils"
            )

    def _check_x11(self) -> None:
        if os.environ.get("DISPLAY"):
            print("  \u2713 X11 (DISPLAY)")
        else:
            print("  \u2717 X11 (DISPLAY) \u2014 not set")
            raise RedictumError(
                "X11 display is required but DISPLAY is not set.\n"
                "Run from an X11 session or set DISPLAY manually."
            )

    # -- Stage 2: installable dependencies ----------------------------------

    def run_stage2(self) -> None:
        """Find missing installable deps and offer to install them."""
        missing_apt = self._find_missing_apt()
        missing_pip = self._find_missing_pip()

        if not missing_apt and not missing_pip:
            return

        # Print summary of missing packages
        if missing_apt:
            print(f"\nMissing system packages: {', '.join(missing_apt)}")
        if missing_pip:
            print(f"Missing Python packages: {', '.join(missing_pip)}")

        if not self._confirm("\nInstall missing dependencies? [y/n]: "):
            print("Skipping installation. Some features may not work.")
            return

        ok = True
        if missing_apt:
            if self._has_apt():
                if not self._install_apt(missing_apt):
                    ok = False
            else:
                print(
                    "apt not found. Install manually:\n  "
                    + " ".join(missing_apt)
                )
                ok = False
        if missing_pip:
            if not self._install_pip(missing_pip):
                ok = False

        if ok:
            print("All dependencies installed.")
        else:
            print("Some dependencies failed to install.")

    def _find_missing_apt(self) -> list[str]:
        """Return list of missing apt package names."""
        missing: list[str] = []
        for name, package in APT_PACKAGES.items():
            if name == "build-essential":
                found = self._check_dpkg(package)
            else:
                found = shutil.which(name) is not None
            if found:
                print(f"  \u2713 {name}")
            else:
                print(f"  \u2717 {name}")
                missing.append(package)
        return missing

    def _find_missing_pip(self) -> list[str]:
        """Return list of missing pip package names."""
        missing: list[str] = []
        for package in PIP_PACKAGES:
            try:
                __import__(package)
                print(f"  \u2713 {package}")
            except ImportError:
                print(f"  \u2717 {package}")
                missing.append(package)
        return missing

    def _install_apt(self, packages: list[str]) -> bool:
        """Run sudo apt install for the given packages. Return success."""
        cmd = ["sudo", "apt", "install", "-y", *packages]
        print(f"Running: {' '.join(cmd)}")
        result = subprocess.run(cmd)
        return result.returncode == 0

    def _install_pip(self, packages: list[str]) -> bool:
        """Run pip install for the given packages. Return success."""
        cmd = ["pip", "install", *packages]
        print(f"Running: {' '.join(cmd)}")
        result = subprocess.run(cmd)
        return result.returncode == 0

    def _has_apt(self) -> bool:
        """Check if apt is available (Debian/Ubuntu/Mint)."""
        return shutil.which("apt") is not None

    def _check_dpkg(self, package: str) -> bool:
        """Check if a package is installed via dpkg -s."""
        try:
            result = subprocess.run(
                ["dpkg", "-s", package],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            return result.returncode == 0
        except FileNotFoundError:
            return False

    def _confirm(self, prompt: str) -> bool:
        """Ask the user y/n via input()."""
        try:
            answer = input(prompt).strip().lower()
        except (EOFError, KeyboardInterrupt):
            print()
            return False
        return answer in ("y", "yes")

    # -- whisper.cpp: warning only ------------------------------------------

    def check_whisper(self) -> None:
        """Warn if whisper.cpp binary or model is missing."""
        cli_path = self._config.get("whisper_cli", "")
        model_path = self._config.get("whisper_model", "")

        if not Path(cli_path).exists():
            print(f"  \u26a0 whisper.cpp not found at {cli_path}")
            print("    Run: ./redictum install-whisper (iteration 6)")
        else:
            print("  \u2713 whisper.cpp")

        if not Path(model_path).exists():
            print(f"  \u26a0 whisper model not found at {model_path}")
            print("    Run: ./redictum install-whisper (iteration 6)")
        else:
            print("  \u2713 whisper model")


def setup_logging(log_path: Path) -> None:
    """Configure file-based logging. Called at daemon and interactive startup."""
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s [%(levelname)s] %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
        handlers=[logging.FileHandler(log_path, encoding="utf-8")],
    )


class Daemon:
    """Manage daemon lifecycle: PID file, double-fork, signal handling."""

    def __init__(self, pid_path: Path, log_path: Path) -> None:
        self._pid_path = pid_path
        self._log_path = log_path
        self._stop_event = threading.Event()

    # -- PID management ------------------------------------------------------

    def _read_pid(self) -> int | None:
        """Read PID from file. Return None if missing or invalid."""
        try:
            text = self._pid_path.read_text().strip()
            return int(text)
        except (FileNotFoundError, ValueError):
            return None

    def _is_running(self, pid: int) -> bool:
        """Check if process with given PID is alive (signal 0)."""
        try:
            os.kill(pid, 0)
            return True
        except ProcessLookupError:
            return False
        except PermissionError:
            return True

    def _write_pid(self) -> None:
        """Write current PID to the PID file."""
        self._pid_path.write_text(f"{os.getpid()}\n")

    def _cleanup(self) -> None:
        """Remove PID file (atexit callback)."""
        try:
            self._pid_path.unlink()
        except FileNotFoundError:
            pass

    # -- Signal handling -----------------------------------------------------

    def _setup_signals(self) -> None:
        """Register SIGTERM and SIGINT handlers."""
        signal.signal(signal.SIGTERM, self._handle_signal)
        signal.signal(signal.SIGINT, self._handle_signal)

    def _handle_signal(self, signum: int, frame: Any) -> None:
        """Set stop event on signal."""
        self._stop_event.set()
        logging.info("Received signal %s, shutting down...", signum)

    # -- Public API ----------------------------------------------------------

    def start(self, target: Callable[[], None]) -> None:
        """Daemonize via double-fork and run target function.

        Args:
            target: Callable to run in the daemon process.
        """
        # Check for existing daemon
        pid = self._read_pid()
        if pid is not None:
            if self._is_running(pid):
                raise RedictumError(
                    f"Daemon is already running (PID {pid})."
                )
            # Stale PID file — clean up
            self._cleanup()

        # First fork
        try:
            pid = os.fork()
        except OSError as exc:
            raise RedictumError(f"First fork failed: {exc}") from exc
        if pid > 0:
            # Parent — wait briefly for child to settle, then exit
            return

        # Child 1: new session
        os.setsid()
        os.umask(0)

        # Second fork
        try:
            pid = os.fork()
        except OSError as exc:
            sys.exit(1)
        if pid > 0:
            # Child 1 exits
            sys.exit(0)

        # Daemon process (child 2)
        # Redirect std file descriptors
        devnull = os.open(os.devnull, os.O_RDWR)
        os.dup2(devnull, sys.stdin.fileno())

        # Redirect stdout/stderr to log file
        log_fd = os.open(
            str(self._log_path),
            os.O_WRONLY | os.O_CREAT | os.O_APPEND,
            0o644,
        )
        os.dup2(log_fd, sys.stdout.fileno())
        os.dup2(log_fd, sys.stderr.fileno())
        os.close(devnull)
        os.close(log_fd)

        # Setup logging
        setup_logging(self._log_path)

        # Write PID file and register cleanup
        self._write_pid()
        atexit.register(self._cleanup)

        # Setup signal handlers
        self._setup_signals()

        logging.info("Daemon started (PID %d)", os.getpid())

        # Run the target
        try:
            target()
        except Exception:
            logging.exception("Daemon target crashed")
        finally:
            logging.info("Daemon stopped (PID %d)", os.getpid())

    def stop(self) -> None:
        """Send SIGTERM to the running daemon and wait for it to exit."""
        pid = self._read_pid()
        if pid is None:
            raise RedictumError("Daemon is not running (no PID file).")
        if not self._is_running(pid):
            # Stale PID — clean up
            self._cleanup()
            raise RedictumError("Daemon is not running (stale PID file removed).")

        os.kill(pid, signal.SIGTERM)

        # Wait for process to exit
        deadline = time.monotonic() + STOP_TIMEOUT
        while time.monotonic() < deadline:
            if not self._is_running(pid):
                return
            time.sleep(0.1)

        print(
            f"Warning: daemon (PID {pid}) did not exit within "
            f"{STOP_TIMEOUT}s after SIGTERM.",
            file=sys.stderr,
        )

    def status(self) -> int | None:
        """Return PID if daemon is running, None otherwise. Cleans stale PID."""
        pid = self._read_pid()
        if pid is None:
            return None
        if self._is_running(pid):
            return pid
        # Stale PID
        self._cleanup()
        return None

    @property
    def stop_event(self) -> threading.Event:
        """Event for the main loop to wait on."""
        return self._stop_event


class AudioRecorder:
    """Record microphone audio via arecord.

    [STUB — iteration 2+]
    """

    def __init__(self, output_dir: Path, sample_rate: int, channels: int) -> None:
        self._output_dir = output_dir
        self._sample_rate = sample_rate
        self._channels = channels

    def start(self) -> None:
        """Begin recording audio."""
        pass

    def stop(self) -> Path | None:
        """Stop recording and return the path to the WAV file.

        Returns:
            Path to the recorded WAV file, or None on failure.
        """
        pass


class AudioProcessor:
    """Normalize audio via ffmpeg.

    [STUB — iteration 2+]
    """

    def normalize(self, input_path: Path) -> Path:
        """Normalize audio levels of the given file.

        Args:
            input_path: Path to the raw audio file.

        Returns:
            Path to the normalized audio file.
        """
        pass


class Transcriber:
    """Transcribe audio via whisper.cpp CLI.

    [STUB — iteration 2+]
    """

    def __init__(self, whisper_cli: str, model_path: str, language: str) -> None:
        self._cli = whisper_cli
        self._model = model_path
        self._language = language

    def transcribe(self, audio_path: Path) -> str:
        """Transcribe the given audio file to text.

        Args:
            audio_path: Path to the audio file.

        Returns:
            Transcribed text string.
        """
        pass


class ClipboardManager:
    """Copy text to clipboard and optionally paste via xdotool.

    [STUB — iteration 2+]
    """

    def copy(self, text: str) -> None:
        """Copy text to the system clipboard.

        Args:
            text: The text to copy.
        """
        pass

    def paste(self) -> None:
        """Simulate Ctrl+V to paste from clipboard."""
        pass


class SoundNotifier:
    """Generate and play WAV feedback tones.

    [STUB — iteration 2+]
    """

    def play_start(self) -> None:
        """Play the 'recording started' tone."""
        pass

    def play_stop(self) -> None:
        """Play the 'recording stopped' tone."""
        pass

    def play_error(self) -> None:
        """Play the 'error occurred' tone."""
        pass


class HotkeyListener:
    """Listen for global hotkeys via pynput.

    [STUB — iteration 2+]
    """

    def __init__(self, hotkey_start: str, hotkey_stop: str) -> None:
        self._hotkey_start = hotkey_start
        self._hotkey_stop = hotkey_stop

    def start(self, on_start: Any = None, on_stop: Any = None) -> None:
        """Start listening for hotkeys.

        Args:
            on_start: Callback invoked when the start hotkey is pressed.
            on_stop: Callback invoked when the stop hotkey is pressed.
        """
        pass

    def stop(self) -> None:
        """Stop the hotkey listener."""
        pass


class Housekeeping:
    """Rotate old audio files and manage log files.

    [STUB — iteration 2+]
    """

    def __init__(self, audio_dir: Path, max_files: int) -> None:
        self._audio_dir = audio_dir
        self._max_files = max_files

    def rotate_audio(self) -> int:
        """Remove oldest audio files exceeding the limit.

        Returns:
            Number of files removed.
        """
        pass

    def cleanup_logs(self, logs_dir: Path) -> None:
        """Clean up old log files.

        Args:
            logs_dir: Path to the logs directory.
        """
        pass


# ---------------------------------------------------------------------------
# RedictumApp — orchestrator
# ---------------------------------------------------------------------------

class RedictumApp:
    """Main application orchestrator that wires all components together."""

    def __init__(self, script_dir: Path) -> None:
        self._script_dir = script_dir
        self._config_mgr = ConfigManager(script_dir)
        self._dir_mgr = DirectoryManager(script_dir)
        self._pid_path = script_dir / PID_FILENAME
        self._log_path = script_dir / "logs" / LOG_FILENAME

    def init(self) -> dict[str, Any]:
        """Initialize config, directories, and run diagnostics.

        Returns:
            Loaded configuration dictionary.

        Raises:
            RedictumError: If a critical dependency is missing.
        """
        config = self._config_mgr.load()
        self._dir_mgr.ensure()
        diag = Diagnostics(config)
        diag.run_stage1()
        diag.run_stage2()
        diag.check_whisper()
        return config

    def run_interactive(self) -> int:
        """Run in interactive (foreground) mode.

        Returns:
            Exit code.
        """
        self.init()
        setup_logging(self._log_path)

        stop_event = threading.Event()

        def handle_signal(signum: int, frame: Any) -> None:
            stop_event.set()

        signal.signal(signal.SIGINT, handle_signal)
        signal.signal(signal.SIGTERM, handle_signal)

        print("Running in interactive mode. Press Ctrl+C to stop.")
        logging.info("Interactive mode started (PID %d)", os.getpid())
        self._main_loop(stop_event)
        logging.info("Interactive mode stopped.")
        return EXIT_OK

    def run_start(self) -> int:
        """Start the daemon.

        Returns:
            Exit code.
        """
        self.init()
        daemon = Daemon(self._pid_path, self._log_path)
        print("Starting daemon...")

        def target() -> None:
            self._main_loop(daemon.stop_event)

        daemon.start(target=target)
        return EXIT_OK

    def run_stop(self) -> int:
        """Stop the daemon.

        Returns:
            Exit code.
        """
        daemon = Daemon(self._pid_path, self._log_path)
        daemon.stop()
        print("Daemon stopped.")
        return EXIT_OK

    def run_status(self) -> int:
        """Print daemon status.

        Returns:
            Exit code.
        """
        daemon = Daemon(self._pid_path, self._log_path)
        pid = daemon.status()
        if pid is not None:
            print(f"Daemon is running (PID {pid})")
        else:
            print("Daemon is not running.")
        return EXIT_OK

    def _main_loop(self, stop_event: threading.Event) -> None:
        """Main loop. [STUB — iteration 4: hotkey + recording + transcription]"""
        while not stop_event.wait(timeout=1.0):
            pass


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------

def build_parser() -> argparse.ArgumentParser:
    """Build and return the argument parser.

    Returns:
        Configured ArgumentParser instance.
    """
    parser = argparse.ArgumentParser(
        prog="redictum",
        description="Redictum Terminal — voice-to-text CLI for Linux.",
    )
    parser.add_argument(
        "--version",
        action="version",
        version=f"redictum {VERSION}",
    )

    sub = parser.add_subparsers(dest="command")

    sub.add_parser("start", help="Start the daemon")
    sub.add_parser("stop", help="Stop the daemon")
    sub.add_parser("status", help="Show daemon status")

    return parser


def main() -> int:
    """Entry point for Redictum Terminal.

    Returns:
        Exit code (0 = success, 1 = error).
    """
    parser = build_parser()
    args = parser.parse_args()

    script_dir = Path(__file__).resolve().parent
    app = RedictumApp(script_dir)

    try:
        if args.command is None:
            return app.run_interactive()
        if args.command == "start":
            return app.run_start()
        if args.command == "stop":
            return app.run_stop()
        if args.command == "status":
            return app.run_status()
    except RedictumError as exc:
        print(f"Error: {exc}", file=sys.stderr)
        return EXIT_ERROR

    return EXIT_OK


if __name__ == "__main__":
    sys.exit(main())
