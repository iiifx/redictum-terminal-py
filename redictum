#!/usr/bin/env python3
"""Redictum Terminal — voice-to-text CLI for Linux.

Author:  Vitaliy Khomenko (Mojam)
AI:      Claude by Anthropic
License: MIT
"""
from __future__ import annotations

import argparse
import atexit
import logging
import math
import os
import re
import signal
import shutil
import struct
import subprocess
import sys
import tempfile
import threading
import time
from datetime import datetime
from pathlib import Path
from typing import Any, Callable

try:
    from rich.console import Console
    _console: Console | None = Console(highlight=False)
except ImportError:
    _console = None

VERSION = "1.0.0"

EXIT_OK = 0
EXIT_ERROR = 1

STATE_IDLE = "idle"
STATE_RECORDING = "recording"
STATE_PROCESSING = "processing"

PID_FILENAME = "redictum.pid"
INITIALIZED_FILENAME = ".initialized"
STOP_TIMEOUT = 3.0

PATH_KEYS: tuple[tuple[str, ...], ...] = (
    ("dependency", "whisper", "cli"),
    ("dependency", "whisper", "model"),
)
REQUIRED_DIRS = ("audio", "transcripts", "logs")

AUDIO_SAMPLE_RATE = 16000
AUDIO_CHANNELS = 1

APT_PACKAGES: dict[str, str] = {
    "ffmpeg": "ffmpeg",
    "xclip": "xclip",
    "xdotool": "xdotool",
}

APT_BUILD_PACKAGES: dict[str, str] = {
    "cmake": "cmake",
    "build-essential": "build-essential",
}

PIP_PACKAGES: dict[str, str] = {
    "pynput": "pynput",
    "rich": "rich",
    "yaml": "PyYAML",
}

# Fallback: pip package → apt package (for PEP 668 systems)
PIP_APT_FALLBACK: dict[str, str] = {
    "pynput": "python3-pynput",
    "PyYAML": "python3-yaml",
    "rich": "python3-rich",
}

DEFAULT_CONFIG: dict[str, Any] = {
    "dependency": {
        "whisper": {
            "cli": "~/whisper.cpp/build/bin/whisper-cli",
            "model": "~/whisper.cpp/models/ggml-large-v3-turbo-q5_0.bin",
            "language": "auto",
            "prompt": "Proper conversational speech with correct punctuation: commas, periods, question marks and exclamation marks. Anglicisms, technical terms and abbreviations are used.",
            "timeout": 120,
        },
    },
    "audio": {
        "recording": {
            "device": "pulse",
            "normalize": True,
        },
    },
    "input": {
        "hotkey": {
            "key": "Insert",
            "hold_delay": 0.6,
            "translate_key": "ctrl+Insert",
        },
    },
    "clipboard": {
        "paste": {
            "auto": True,
            "prefix": "",
            "postfix": " ",
        },
    },
    "notification": {
        "sound": {
            "signal_volume": 30,
            "signal_start": True,
            "signal_processing": False,
            "signal_done": True,
            "signal_error": True,
        },
    },
    "storage": {
        "audio": {
            "max_files": 50,
        },
        "transcripts": {
            "max_files": 50,
        },
    },
}

DEFAULT_CONFIG_YAML: str = """\
# =============================================================================
# Redictum Terminal — Configuration
# =============================================================================

# --- External Dependencies ---------------------------------------------------

dependency:
  whisper:
    # Path to whisper-cli binary
    cli: "~/whisper.cpp/build/bin/whisper-cli"

    # Path to whisper model file
    model: "~/whisper.cpp/models/ggml-large-v3-turbo-q5_0.bin"

    # Language for transcription: "auto" detects from system locale,
    # or set explicitly (e.g., "ru", "en", "uk", "de", "fr")
    language: "auto"

    # Optional prompt to guide whisper transcription
    # Helps with domain-specific vocabulary and punctuation
    prompt: "Proper conversational speech with correct punctuation: commas, periods, question marks and exclamation marks. Anglicisms, technical terms and abbreviations are used."

    # Maximum time (seconds) to wait for transcription to finish
    timeout: 120


# --- Audio Recording ---------------------------------------------------------

audio:
  recording:
    # ALSA recording device ("pulse" for PulseAudio)
    device: "pulse"

    # Normalize audio via ffmpeg loudnorm before transcription
    normalize: true

# --- Input -------------------------------------------------------------------

input:
  hotkey:
    # Push-to-talk key name (e.g., "Insert", "F12", "Pause", "scroll_lock")
    key: "Insert"

    # How long (seconds) to hold the key before recording starts
    hold_delay: 0.6

    # Hotkey for translate mode (transcribe + translate to English)
    # Format: "ctrl+Insert", "alt+F12", or empty string to disable
    translate_key: "ctrl+Insert"

# --- Clipboard ---------------------------------------------------------------

clipboard:
  paste:
    # Auto-paste transcribed text via xdotool (Ctrl+V)
    auto: true

    # Text added before transcription result
    prefix: ""

    # Text added after transcription result
    postfix: " "

# --- Notifications -----------------------------------------------------------

notification:
  sound:
    # Sound volume (0-100, mapped to PulseAudio range)
    signal_volume: 30

    # Sound when recording starts
    signal_start: true

    # Sound when transcription begins
    signal_processing: false

    # Sound when transcription is done
    signal_done: true

    # Sound on error
    signal_error: true

# --- Storage -----------------------------------------------------------------

storage:
  audio:
    # Maximum number of audio files to keep (oldest are deleted)
    max_files: 50

  transcripts:
    # Maximum number of daily transcript files to keep (oldest are deleted)
    max_files: 50

  logs:
    # Maximum number of session log files to keep (oldest are deleted)
    max_files: 50
"""


class RedictumError(Exception):
    """Base exception for Redictum Terminal errors."""


def _rprint(text: str) -> None:
    """Print with rich markup if available, plain print otherwise."""
    if _console is not None:
        _console.print(text)
    else:
        print(re.sub(r"\[/?[^\]]*\]", "", text))


def _confirm(prompt: str, default: bool = False) -> bool:
    """Ask the user y/n via input(). Return *default* on empty Enter.

    The hint ``[Y/n]`` or ``[y/N]`` is appended automatically.
    Return False on EOF/Ctrl+C.
    """
    hint = "[Y/n]" if default else "[y/N]"
    try:
        answer = input(f"{prompt} {hint}: ").strip().lower()
    except (EOFError, KeyboardInterrupt):
        print()
        return False
    if not answer:
        return default
    return answer in ("y", "yes")


# ---------------------------------------------------------------------------
# ConfigManager
# ---------------------------------------------------------------------------

class ConfigManager:
    """Manages config.yaml: generation, loading, merging with defaults.

    Config file lives next to the script. Missing keys are filled from
    DEFAULT_CONFIG; extra keys in the user file are preserved.
    Comments in YAML are preserved across updates.
    """

    def __init__(self, script_dir: Path) -> None:
        self._path = script_dir / "config.yaml"

    @property
    def path(self) -> Path:
        """Return the resolved config file path."""
        return self._path

    def load(self) -> dict[str, Any]:
        """Load config from disk or generate a default one.

        Returns:
            Merged configuration dictionary (nested).

        Raises:
            RedictumError: If config.yaml exists but contains invalid YAML.
        """
        if not self._path.exists():
            self._write_default()
            return self._expand_paths(self._deep_copy(DEFAULT_CONFIG))

        import yaml  # late import: available after diagnostics installs PyYAML

        try:
            raw = self._path.read_text(encoding="utf-8")
            user_config = yaml.safe_load(raw)
        except yaml.YAMLError as exc:
            raise RedictumError(
                f"Invalid YAML in {self._path}: {exc}"
            ) from exc

        if not isinstance(user_config, dict):
            user_config = {}

        merged = self._deep_copy(DEFAULT_CONFIG)
        self._deep_merge(merged, user_config)
        return self._expand_paths(merged)

    def update(self, updates: dict[str, str]) -> None:
        """Update leaf keys in config.yaml, preserving comments.

        Performs line-by-line value replacement so that the YAML template
        structure and comments remain intact.  Leaf key names must be
        unique across the entire config.

        Args:
            updates: ``{leaf_key: value}`` pairs, e.g. ``{"cli": "/path"}``.
        """
        if self._path.exists():
            text = self._path.read_text(encoding="utf-8")
        else:
            text = DEFAULT_CONFIG_YAML

        for key, value in updates.items():
            yaml_val = self._format_value(value)
            text = re.sub(
                rf"^(\s*{re.escape(key)}:)\s+.*$",
                rf"\1 {yaml_val}",
                text,
                count=1,
                flags=re.MULTILINE,
            )

        self._path.write_text(text, encoding="utf-8")

    # -- private helpers -----------------------------------------------------

    def _write_default(self) -> None:
        """Write DEFAULT_CONFIG_YAML template with comments."""
        self._path.write_text(DEFAULT_CONFIG_YAML, encoding="utf-8")

    @staticmethod
    def _format_value(value: Any) -> str:
        """Format a Python value for YAML output."""
        if isinstance(value, bool):
            return "true" if value else "false"
        if isinstance(value, str):
            return f'"{value}"'
        return str(value)

    @staticmethod
    def _deep_copy(d: dict[str, Any]) -> dict[str, Any]:
        """Return a deep copy of a nested dict (no import needed)."""
        out: dict[str, Any] = {}
        for k, v in d.items():
            out[k] = ConfigManager._deep_copy(v) if isinstance(v, dict) else v
        return out

    @staticmethod
    def _deep_merge(base: dict[str, Any], override: dict[str, Any]) -> None:
        """Recursively merge *override* into *base* in place."""
        for k, v in override.items():
            if k in base and isinstance(base[k], dict) and isinstance(v, dict):
                ConfigManager._deep_merge(base[k], v)
            else:
                base[k] = v

    @staticmethod
    def _expand_paths(config: dict[str, Any]) -> dict[str, Any]:
        """Expand ``~`` in path-valued keys (nested paths)."""
        for path_keys in PATH_KEYS:
            node: Any = config
            for part in path_keys[:-1]:
                node = node.get(part, {})
            leaf = path_keys[-1]
            if leaf in node and isinstance(node[leaf], str):
                node[leaf] = str(Path(node[leaf]).expanduser())
        return config


# ---------------------------------------------------------------------------
# DirectoryManager
# ---------------------------------------------------------------------------

class DirectoryManager:
    """Creates required working directories next to the script.

    Directories: audio/, transcripts/, logs/.
    """

    def __init__(self, script_dir: Path) -> None:
        self._script_dir = script_dir

    def ensure(self) -> None:
        """Create all required directories if they don't exist."""
        for name in REQUIRED_DIRS:
            (self._script_dir / name).mkdir(exist_ok=True)


# ---------------------------------------------------------------------------
# Stubs
# ---------------------------------------------------------------------------

class Diagnostics:
    """Check external dependencies and offer auto-installation.

    Stage 1 — critical checks (fail fast): Python 3.10+, Linux, PulseAudio,
    ALSA, X11. If any fail, raise RedictumError.

    Stage 2 — installable dependencies (auto-fix): apt and pip packages.
    Offer to install missing ones, user confirms with y/n.

    whisper.cpp — offer auto-install if missing (clone, build, model download).
    """

    def __init__(self, config: dict[str, Any], config_mgr: ConfigManager) -> None:
        self._config = config
        self._config_mgr = config_mgr

    # -- Stage 1: critical checks -------------------------------------------

    def run_stage1(self) -> None:
        """Run all critical checks. Raise RedictumError on first failure."""
        _rprint("[bold]Checking dependencies...[/bold]")
        self._check_python()
        self._check_linux()
        self._check_pulseaudio()
        self._check_alsa()
        self._check_x11()

    def _check_python(self) -> None:
        ver = sys.version_info
        label = f"Python {ver.major}.{ver.minor}.{ver.micro}"
        if ver >= (3, 10):
            _rprint(f"  [green]\u2713[/green] {label}")
        else:
            _rprint(f"  [red]\u2717[/red] {label}")
            raise RedictumError(
                f"Python 3.10+ is required, found {label}."
            )

    def _check_linux(self) -> None:
        if sys.platform == "linux":
            _rprint("  [green]\u2713[/green] Linux")
        else:
            _rprint(f"  [red]\u2717[/red] Linux — detected {sys.platform}")
            raise RedictumError(
                f"Linux is required, detected platform: {sys.platform}."
            )

    def _check_pulseaudio(self) -> None:
        if shutil.which("paplay"):
            _rprint("  [green]\u2713[/green] PulseAudio (paplay)")
        else:
            _rprint("  [red]\u2717[/red] PulseAudio (paplay) \u2014 not found")
            raise RedictumError(
                "PulseAudio (paplay) is required but not found.\n"
                "Install it manually: sudo apt install pulseaudio-utils"
            )

    def _check_alsa(self) -> None:
        if shutil.which("arecord"):
            _rprint("  [green]\u2713[/green] ALSA (arecord)")
        else:
            _rprint("  [red]\u2717[/red] ALSA (arecord) \u2014 not found")
            raise RedictumError(
                "ALSA (arecord) is required but not found.\n"
                "Install it manually: sudo apt install alsa-utils"
            )

    def _check_x11(self) -> None:
        if os.environ.get("DISPLAY"):
            _rprint("  [green]\u2713[/green] X11 (DISPLAY)")
        else:
            _rprint("  [red]\u2717[/red] X11 (DISPLAY) \u2014 not set")
            raise RedictumError(
                "X11 display is required but DISPLAY is not set.\n"
                "Run from an X11 session or set DISPLAY manually."
            )

    # -- Stage 2: installable dependencies ----------------------------------

    def run_stage2(self) -> None:
        """Find missing installable deps and offer to install them."""
        missing_apt = self._find_missing_apt()
        missing_pip = self._find_missing_pip()

        if not missing_apt and not missing_pip:
            return

        # Print summary of missing packages
        if missing_apt:
            _rprint(f"\nMissing system packages: {', '.join(missing_apt)}")
        if missing_pip:
            _rprint(f"Missing Python packages: {', '.join(missing_pip)}")

        if not _confirm("\nInstall missing dependencies?", default=True):
            _rprint("[yellow]Skipping installation. Some features may not work.[/yellow]")
            return

        ok = True
        if missing_apt:
            if self._has_apt():
                if not self._install_apt(missing_apt):
                    ok = False
            else:
                _rprint(
                    "[yellow]apt not found. Install manually:[/yellow]\n  "
                    + " ".join(missing_apt)
                )
                ok = False
        if missing_pip:
            if not self._install_pip(missing_pip):
                ok = False

        if ok:
            _rprint("[green]All dependencies installed.[/green]")
        else:
            _rprint("[yellow]Some dependencies failed to install.[/yellow]")

    def _find_missing_apt(self) -> list[str]:
        """Return list of missing apt package names."""
        missing: list[str] = []
        for name, package in {**APT_PACKAGES, **APT_BUILD_PACKAGES}.items():
            if name == "build-essential":
                found = self._check_dpkg(package)
            else:
                found = shutil.which(name) is not None
            if found:
                _rprint(f"  [green]\u2713[/green] {name}")
            else:
                _rprint(f"  [red]\u2717[/red] {name}")
                missing.append(package)
        return missing

    def _find_missing_pip(self) -> list[str]:
        """Return list of missing pip package names."""
        missing: list[str] = []
        for import_name, pip_name in PIP_PACKAGES.items():
            try:
                __import__(import_name)
                _rprint(f"  [green]\u2713[/green] {pip_name}")
            except ImportError:
                _rprint(f"  [red]\u2717[/red] {pip_name}")
                missing.append(pip_name)
        return missing

    def _install_apt(self, packages: list[str]) -> bool:
        """Run sudo apt install for the given packages. Return success."""
        cmd = ["sudo", "apt", "install", "-y", *packages]
        _rprint(f"[dim]Running: {' '.join(cmd)}[/dim]")
        result = subprocess.run(cmd)
        return result.returncode == 0

    def _install_pip(self, packages: list[str]) -> bool:
        """Install Python packages with PEP 668 fallback chain.

        Strategy:
        1. Try ``pip install`` (works on older systems and in containers).
        2. If blocked by PEP 668, try ``apt install python3-*`` equivalents.
        3. If apt unavailable/failed, try ``pip install --break-system-packages``.
        4. If everything fails, print manual instructions.
        """
        # 1. Try normal pip install
        cmd = [sys.executable, "-m", "pip", "install", *packages]
        _rprint(f"[dim]Running: {' '.join(cmd)}[/dim]")
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            return True

        # Check if this is PEP 668 block
        if "externally-managed" not in result.stderr.lower():
            # Some other error — show it
            if result.stderr:
                _rprint(f"[red]{result.stderr.strip()}[/red]")
            return False

        _rprint("[yellow]System Python is externally managed (PEP 668).[/yellow]")

        # 2. Try apt equivalents
        apt_packages = [
            PIP_APT_FALLBACK[p]
            for p in packages
            if p in PIP_APT_FALLBACK
        ]
        if apt_packages and self._has_apt():
            _rprint(f"[dim]Trying apt: {' '.join(apt_packages)}[/dim]")
            if self._install_apt(apt_packages):
                return True

        # 3. Try pip with --break-system-packages
        cmd = [
            sys.executable, "-m", "pip", "install",
            "--break-system-packages", *packages,
        ]
        _rprint(f"[dim]Running: {' '.join(cmd)}[/dim]")
        result = subprocess.run(cmd)
        if result.returncode == 0:
            return True

        # 4. All failed — manual instructions
        _rprint(
            "[red]Could not install Python packages automatically.[/red]\n"
            "Try one of:\n"
            f"  sudo apt install {' '.join(apt_packages)}\n"
            f"  pip install --user {' '.join(packages)}\n"
            f"  pip install --break-system-packages {' '.join(packages)}"
        )
        return False

    def _has_apt(self) -> bool:
        """Check if apt is available (Debian/Ubuntu/Mint)."""
        return shutil.which("apt") is not None

    def _check_dpkg(self, package: str) -> bool:
        """Check if a package is installed via dpkg -s."""
        try:
            result = subprocess.run(
                ["dpkg", "-s", package],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            return result.returncode == 0
        except FileNotFoundError:
            return False

    # -- whisper.cpp: warning only ------------------------------------------

    def check_whisper(self) -> None:
        """Check whisper.cpp and model, offer installation if missing."""
        whisper = self._config.get("dependency", {}).get("whisper", {})
        cli_path = whisper.get("cli", "")
        model_path = whisper.get("model", "")
        cli_ok = bool(cli_path) and Path(cli_path).exists()
        model_ok = bool(model_path) and Path(model_path).exists()

        if cli_ok:
            _rprint("  [green]\u2713[/green] whisper.cpp")
        else:
            _rprint(f"  [yellow]\u26a0[/yellow] whisper.cpp not found at {cli_path}")

        if model_ok:
            _rprint("  [green]\u2713[/green] whisper model")
        else:
            _rprint(f"  [yellow]\u26a0[/yellow] whisper model not found at {model_path}")

        if cli_ok and model_ok:
            return

        if _confirm("\nInstall whisper.cpp?", default=True):
            installer = WhisperInstaller(self._config_mgr)
            installer.install()
        else:
            _rprint(
                "[yellow]Skipping. You can install later with:[/yellow] "
                "[bold]./redictum whisper[/bold]"
            )


class WhisperInstaller:
    """Setup wizard for whisper.cpp: install, configure, reconfigure."""

    WHISPER_VERSION = "v1.8.3"
    TARBALL_URL = "https://github.com/ggerganov/whisper.cpp/archive/refs/tags/{version}.tar.gz"
    HF_BASE = "https://huggingface.co/ggerganov/whisper.cpp/resolve/main"

    MODELS: list[tuple[str, str, str]] = [
        ("large-v3-turbo-q5_0", "ggml-large-v3-turbo-q5_0.bin", "~547 MB, best speed/quality"),
        ("large-v3-turbo", "ggml-large-v3-turbo.bin", "~1.6 GB, full turbo"),
        ("large-v3", "ggml-large-v3.bin", "~3.1 GB, highest quality"),
        ("medium", "ggml-medium.bin", "~1.5 GB"),
        ("small", "ggml-small.bin", "~466 MB"),
        ("base", "ggml-base.bin", "~142 MB"),
        ("tiny", "ggml-tiny.bin", "~75 MB, fastest"),
    ]

    def __init__(self, config_mgr: ConfigManager) -> None:
        self._config_mgr = config_mgr
        self._install_dir = Path.home() / "whisper.cpp"

    # -- Public API ----------------------------------------------------------

    def install(self) -> None:
        """Smart setup: detect state, install/reconfigure as needed."""
        _rprint("\n[bold]whisper.cpp Setup[/bold]")

        cli_path = self._install_dir / "build" / "bin" / "whisper-cli"

        if cli_path.exists():
            self._reconfigure(cli_path)
        else:
            self._fresh_install()

    # -- Flows ---------------------------------------------------------------

    def _fresh_install(self) -> None:
        """Full install: ensure CUDA, download, build, download model."""
        cuda_available = self._ensure_cuda()
        self._clone()
        self._build(use_cuda=cuda_available)

        cli_path = self._install_dir / "build" / "bin" / "whisper-cli"
        if not cli_path.exists():
            raise RedictumError(
                f"Build completed but whisper-cli not found at {cli_path}"
            )

        model_path = self._select_and_download()
        self._update_config(cli_path, model_path)
        _rprint("\n[green]whisper.cpp setup complete![/green]")

    def _reconfigure(self, cli_path: Path) -> None:
        """Re-check existing install, offer improvements."""
        cuda_linked = self._is_cuda_linked(cli_path)

        if cuda_linked:
            _rprint("  [green]\u2713[/green] whisper.cpp [bold](CUDA)[/bold]")
        else:
            _rprint("  [green]\u2713[/green] whisper.cpp [dim](CPU-only)[/dim]")

        # Offer CUDA rebuild if beneficial
        need_rebuild = False
        if not cuda_linked:
            cuda_ok = self._ensure_cuda()
            if cuda_ok:
                _rprint("  [yellow]\u26a0[/yellow] CUDA ready but whisper.cpp built without it")
                if _confirm("  Rebuild with CUDA for GPU acceleration?", default=True):
                    need_rebuild = True

        if need_rebuild:
            self._clone()
            self._build(use_cuda=True)
            cli_path = self._install_dir / "build" / "bin" / "whisper-cli"

        model_path = self._ensure_model()
        self._update_config(cli_path, model_path)

        if need_rebuild:
            _rprint("\n[green]whisper.cpp reconfigured![/green]")

    # -- CUDA ----------------------------------------------------------------

    CUDA_MIN_VERSION = 12
    CUDA_KEYRING_URL = (
        "https://developer.download.nvidia.com/compute/cuda/repos"
        "/{distro}/x86_64/cuda-keyring_1.1-1_all.deb"
    )

    def _is_cuda_available(self) -> bool:
        """Check if a modern enough nvcc is available."""
        ver = self._get_nvcc_version()
        return ver is not None and ver >= self.CUDA_MIN_VERSION

    def _is_cuda_linked(self, cli_path: Path) -> bool:
        """Check if the binary links against CUDA libraries."""
        try:
            result = subprocess.run(
                ["ldd", str(cli_path)],
                capture_output=True, text=True, timeout=10,
            )
            output = result.stdout.lower()
            return "cuda" in output or "cublas" in output
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return False

    def _get_nvcc_version(self) -> int | None:
        """Return major CUDA version from nvcc, or None."""
        nvcc = self._find_nvcc()
        if not nvcc:
            return None
        try:
            result = subprocess.run(
                [nvcc, "--version"],
                capture_output=True, text=True, timeout=10,
            )
            # Parse "release 12.8, V12.8.61"
            m = re.search(r"release (\d+)\.", result.stdout)
            return int(m.group(1)) if m else None
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return None

    def _find_nvcc(self) -> str | None:
        """Find nvcc, preferring newest /usr/local/cuda-* over PATH."""
        # Check /usr/local/cuda-* first (NVIDIA repo installs here)
        for cuda_dir in sorted(Path("/usr/local").glob("cuda-*"), reverse=True):
            candidate = cuda_dir / "bin" / "nvcc"
            if candidate.exists():
                return str(candidate)
        # Fall back to PATH (may be old distro package)
        return shutil.which("nvcc")

    def _ensure_cuda(self) -> bool:
        """Check CUDA availability, offer to install/upgrade if needed."""
        nvcc_ver = self._get_nvcc_version()
        if nvcc_ver is not None and nvcc_ver >= self.CUDA_MIN_VERSION:
            _rprint(f"  [green]\u2713[/green] CUDA toolkit {nvcc_ver}")
            return True

        if not shutil.which("nvidia-smi"):
            _rprint("  [dim]No NVIDIA GPU detected, building CPU-only[/dim]")
            return False

        if nvcc_ver is not None:
            _rprint(
                f"  [yellow]\u26a0[/yellow] CUDA toolkit {nvcc_ver} is too old "
                f"(need {self.CUDA_MIN_VERSION}+)"
            )
        else:
            _rprint("  [yellow]\u26a0[/yellow] NVIDIA GPU detected but CUDA toolkit not installed")

        if _confirm("  Install CUDA toolkit from NVIDIA repository?", default=True):
            if self._install_cuda_toolkit():
                return True
        _rprint("  [dim]Continuing with CPU-only build[/dim]")
        return False

    def _detect_ubuntu_distro(self) -> str | None:
        """Detect Ubuntu base for NVIDIA repo (e.g. 'ubuntu2204')."""
        try:
            text = Path("/etc/os-release").read_text()
        except FileNotFoundError:
            return None
        # Mint, Pop!_OS etc. have UBUNTU_CODENAME
        m = re.search(r'UBUNTU_CODENAME=(\w+)', text)
        if not m:
            m = re.search(r'VERSION_CODENAME=(\w+)', text)
        if not m:
            return None
        codename = m.group(1)
        codename_map: dict[str, str] = {
            "focal": "ubuntu2004",
            "jammy": "ubuntu2204",
            "noble": "ubuntu2404",
        }
        return codename_map.get(codename)

    def _install_cuda_toolkit(self) -> bool:
        """Install CUDA toolkit from NVIDIA apt repository."""
        distro = self._detect_ubuntu_distro()
        if not distro:
            _rprint(
                "  [yellow]\u26a0[/yellow] Could not detect Ubuntu version. "
                "Install CUDA toolkit manually:\n"
                "    https://developer.nvidia.com/cuda-downloads"
            )
            return False

        _rprint(f"  Detected base: {distro}")

        # Download and install keyring
        keyring_url = self.CUDA_KEYRING_URL.format(distro=distro)
        fd, keyring_path = tempfile.mkstemp(suffix=".deb", prefix="cuda-keyring-")
        keyring_deb = Path(keyring_path)
        os.close(fd)

        try:
            _rprint("  [dim]Downloading NVIDIA CUDA keyring...[/dim]")
            dl_cmd: list[str] = []
            if shutil.which("curl"):
                dl_cmd = ["curl", "-fsSL", "-o", str(keyring_deb), keyring_url]
            elif shutil.which("wget"):
                dl_cmd = ["wget", "-q", "-O", str(keyring_deb), keyring_url]
            else:
                _rprint("  [red]Neither curl nor wget found[/red]")
                return False

            if subprocess.run(dl_cmd).returncode != 0:
                _rprint("  [yellow]\u26a0[/yellow] Failed to download CUDA keyring")
                return False

            _rprint("  [dim]Installing CUDA keyring and toolkit (sudo required)...[/dim]")
            result = subprocess.run(["sudo", "dpkg", "-i", str(keyring_deb)])
            if result.returncode != 0:
                _rprint("  [yellow]\u26a0[/yellow] Failed to install CUDA keyring")
                return False

            result = subprocess.run(["sudo", "apt-get", "update", "-qq"])
            if result.returncode != 0:
                _rprint("  [yellow]\u26a0[/yellow] Failed to update package list")
                return False

            result = subprocess.run(
                ["sudo", "apt-get", "install", "-y", "cuda-toolkit"],
            )
            if result.returncode != 0:
                _rprint("  [yellow]\u26a0[/yellow] CUDA toolkit installation failed")
                return False

            # Verify new nvcc
            ver = self._get_nvcc_version()
            if ver and ver >= self.CUDA_MIN_VERSION:
                _rprint(f"  [green]\u2713[/green] CUDA toolkit {ver} installed")
                return True

            _rprint("  [yellow]\u26a0[/yellow] CUDA installed but nvcc not found in PATH")
            return False
        finally:
            keyring_deb.unlink(missing_ok=True)

    # -- Clone / Build -------------------------------------------------------

    def _clone(self) -> None:
        """Download and extract the whisper.cpp release tarball."""
        url = self.TARBALL_URL.format(version=self.WHISPER_VERSION)
        fd, tarball_path = tempfile.mkstemp(suffix=".tar.gz", prefix="whisper-cpp-")
        tarball = Path(tarball_path)
        os.close(fd)

        try:
            if self._install_dir.exists():
                _rprint(f"  Removing old {self._install_dir}...")
                shutil.rmtree(self._install_dir)

            _rprint(f"  Downloading whisper.cpp {self.WHISPER_VERSION}...")
            if shutil.which("curl"):
                cmd = ["curl", "-fsSL", "-o", str(tarball), url]
            elif shutil.which("wget"):
                cmd = ["wget", "-q", "-O", str(tarball), url]
            else:
                raise RedictumError("Neither curl nor wget found")

            result = subprocess.run(cmd)
            if result.returncode != 0:
                raise RedictumError("Failed to download whisper.cpp tarball")

            _rprint("  Extracting...")
            result = subprocess.run(
                ["tar", "xzf", str(tarball), "-C", str(self._install_dir.parent)],
            )
            if result.returncode != 0:
                raise RedictumError("Failed to extract whisper.cpp tarball")

            # tar extracts to whisper.cpp-<version> (without 'v' prefix)
            version_stripped = self.WHISPER_VERSION.lstrip("v")
            extracted = self._install_dir.parent / f"whisper.cpp-{version_stripped}"
            if extracted.exists():
                extracted.rename(self._install_dir)
            elif not self._install_dir.exists():
                raise RedictumError(
                    f"Expected directory {extracted} not found after extraction"
                )

            _rprint(f"  [green]\u2713[/green] whisper.cpp {self.WHISPER_VERSION} ready")
        finally:
            tarball.unlink(missing_ok=True)

    def _build(self, use_cuda: bool) -> None:
        """Configure and build whisper.cpp."""
        # Clean previous build
        build_dir = self._install_dir / "build"
        if build_dir.exists():
            shutil.rmtree(build_dir)

        mode = "CUDA" if use_cuda else "CPU"
        _rprint(f"  Configuring build ({mode})...")
        cmake_args = [
            "cmake", "-B", "build",
            "-DCMAKE_BUILD_TYPE=Release",
        ]
        if use_cuda:
            cmake_args.append("-DGGML_CUDA=ON")
            nvcc = self._find_nvcc()
            if nvcc and nvcc != shutil.which("nvcc"):
                cmake_args.append(f"-DCMAKE_CUDA_COMPILER={nvcc}")

        result = subprocess.run(
            cmake_args,
            cwd=str(self._install_dir),
            capture_output=True, text=True,
        )
        if result.returncode != 0:
            if use_cuda:
                _rprint("  [yellow]\u26a0[/yellow] CUDA configure failed:")
                for line in result.stderr.strip().split("\n")[-3:]:
                    _rprint(f"    [dim]{line}[/dim]")
                _rprint("  Retrying with CPU-only...")
                self._build(use_cuda=False)
                return
            raise RedictumError(
                f"cmake configure failed:\n{result.stderr[:500]}"
            )
        _rprint(f"  [green]\u2713[/green] Configured ({mode})")

        jobs = os.cpu_count() or 1
        if use_cuda:
            _rprint(f"  Building ({mode}, {jobs} jobs)...")
            _rprint("  [yellow]CUDA build takes 10-15 min. Do not interrupt![/yellow]")
        else:
            _rprint(f"  Building ({mode}, {jobs} jobs, may take several minutes)...")
        result = subprocess.run(
            ["cmake", "--build", "build", "--config", "Release",
             "-j", str(jobs)],
            cwd=str(self._install_dir),
            capture_output=True, text=True,
        )
        if result.returncode != 0:
            if use_cuda:
                err = result.stderr or result.stdout or ""
                _rprint("  [yellow]\u26a0[/yellow] CUDA build failed:")
                for line in err.strip().split("\n")[-5:]:
                    _rprint(f"    [dim]{line}[/dim]")
                _rprint("  Retrying with CPU-only...")
                self._build(use_cuda=False)
                return
            raise RedictumError("cmake build failed")
        _rprint(f"  [green]\u2713[/green] Build complete ({mode})")

    # -- Model ---------------------------------------------------------------

    def _select_and_download(self) -> Path:
        """Let the user pick a model and download it."""
        _rprint("\n  [bold]Available models:[/bold]")
        for i, (name, _filename, desc) in enumerate(self.MODELS, 1):
            marker = " [bold](recommended)[/bold]" if i == 1 else ""
            _rprint(f"    {i}. {name} — {desc}{marker}")

        while True:
            try:
                choice = input(
                    f"\n  Select model [1-{len(self.MODELS)}, default=1]: "
                ).strip()
            except (EOFError, KeyboardInterrupt):
                print()
                choice = ""
            if not choice:
                choice = "1"
            try:
                idx = int(choice) - 1
                if 0 <= idx < len(self.MODELS):
                    break
            except ValueError:
                pass
            _rprint(f"  [red]Invalid choice, enter 1-{len(self.MODELS)}[/red]")

        _name, filename, _desc = self.MODELS[idx]
        return self._download_model(filename)

    def _download_model(self, filename: str) -> Path:
        """Download a model file from Hugging Face."""
        models_dir = self._install_dir / "models"
        models_dir.mkdir(exist_ok=True)
        model_path = models_dir / filename

        if model_path.exists():
            _rprint(f"  [green]\u2713[/green] Model already downloaded: {filename}")
            return model_path

        url = f"{self.HF_BASE}/{filename}"
        _rprint(f"  Downloading {filename}...")

        # Prefer curl, fall back to wget
        if shutil.which("curl"):
            cmd = ["curl", "-L", "-o", str(model_path), "--progress-bar", url]
        elif shutil.which("wget"):
            cmd = ["wget", "-O", str(model_path), "--show-progress", "-q", url]
        else:
            raise RedictumError(
                "Neither curl nor wget found. Install one: "
                "sudo apt install curl"
            )

        result = subprocess.run(cmd)
        if result.returncode != 0 or not model_path.exists():
            if model_path.exists():
                model_path.unlink()
            raise RedictumError(f"Model download failed: {filename}")

        _rprint(f"  [green]\u2713[/green] Model downloaded: {filename}")
        return model_path

    def _ensure_model(self) -> Path:
        """Check if a model exists, offer download if not."""
        config = self._config_mgr.load()
        model_path_str = config.get("dependency", {}).get("whisper", {}).get("model", "")
        if model_path_str and Path(model_path_str).exists():
            _rprint(f"  [green]\u2713[/green] Model: {Path(model_path_str).name}")
            return Path(model_path_str)
        return self._select_and_download()

    # -- Config --------------------------------------------------------------

    def _update_config(self, cli_path: Path, model_path: Path) -> None:
        """Write whisper paths to config.yaml."""
        home = str(Path.home())
        cli_str = str(cli_path)
        model_str = str(model_path)
        if cli_str.startswith(home):
            cli_str = "~" + cli_str[len(home):]
        if model_str.startswith(home):
            model_str = "~" + model_str[len(home):]
        self._config_mgr.update({
            "cli": cli_str,
            "model": model_str,
        })
        _rprint("  [green]\u2713[/green] Config updated")


def setup_logging(log_path: Path) -> None:
    """Configure file-based logging. Called at daemon and interactive startup."""
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s [%(levelname)s] %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
        handlers=[logging.FileHandler(log_path, encoding="utf-8")],
    )


class Daemon:
    """Manage daemon lifecycle: PID file, double-fork, signal handling."""

    def __init__(self, pid_path: Path, log_path: Path) -> None:
        self._pid_path = pid_path
        self._log_path = log_path
        self._stop_event = threading.Event()

    # -- PID management ------------------------------------------------------

    def _read_pid(self) -> int | None:
        """Read PID from file. Return None if missing or invalid."""
        try:
            text = self._pid_path.read_text().strip()
            return int(text)
        except (FileNotFoundError, ValueError):
            return None

    def _is_running(self, pid: int) -> bool:
        """Check if process with given PID is alive (signal 0)."""
        try:
            os.kill(pid, 0)
            return True
        except ProcessLookupError:
            return False
        except PermissionError:
            return True

    def _write_pid(self) -> None:
        """Write current PID to the PID file."""
        self._pid_path.write_text(f"{os.getpid()}\n")

    def _cleanup(self) -> None:
        """Remove PID file (atexit callback)."""
        try:
            self._pid_path.unlink()
        except FileNotFoundError:
            pass

    # -- Signal handling -----------------------------------------------------

    def _setup_signals(self) -> None:
        """Register SIGTERM and SIGINT handlers."""
        signal.signal(signal.SIGTERM, self._handle_signal)
        signal.signal(signal.SIGINT, self._handle_signal)

    def _handle_signal(self, signum: int, frame: Any) -> None:
        """Set stop event on signal."""
        self._stop_event.set()
        logging.info("Received signal %s, shutting down...", signum)

    # -- Public API ----------------------------------------------------------

    def start(self, target: Callable[[], None]) -> None:
        """Daemonize via double-fork and run target function.

        Args:
            target: Callable to run in the daemon process.
        """
        # Check for existing daemon
        pid = self._read_pid()
        if pid is not None:
            if self._is_running(pid):
                raise RedictumError(
                    f"Daemon is already running (PID {pid})."
                )
            # Stale PID file — clean up
            self._cleanup()

        # First fork
        try:
            pid = os.fork()
        except OSError as exc:
            raise RedictumError(f"First fork failed: {exc}") from exc
        if pid > 0:
            # Parent — wait briefly for child to settle, then exit
            return

        # Child 1: new session
        os.setsid()
        os.umask(0)

        # Second fork
        try:
            pid = os.fork()
        except OSError as exc:
            sys.exit(1)
        if pid > 0:
            # Child 1 exits
            sys.exit(0)

        # Daemon process (child 2)
        # Redirect std file descriptors
        devnull = os.open(os.devnull, os.O_RDWR)
        os.dup2(devnull, sys.stdin.fileno())

        # Redirect stdout/stderr to log file
        log_fd = os.open(
            str(self._log_path),
            os.O_WRONLY | os.O_CREAT | os.O_APPEND,
            0o644,
        )
        os.dup2(log_fd, sys.stdout.fileno())
        os.dup2(log_fd, sys.stderr.fileno())
        os.close(devnull)
        os.close(log_fd)

        # Setup logging
        setup_logging(self._log_path)

        # Write PID file and register cleanup
        self._write_pid()
        atexit.register(self._cleanup)

        # Setup signal handlers
        self._setup_signals()

        logging.info("Daemon started (PID %d)", os.getpid())

        # Run the target
        try:
            target()
        except Exception:
            logging.exception("Daemon target crashed")
        finally:
            logging.info("Daemon stopped (PID %d)", os.getpid())

    def stop(self) -> None:
        """Send SIGTERM to the running daemon and wait for it to exit."""
        pid = self._read_pid()
        if pid is None:
            raise RedictumError("Daemon is not running (no PID file).")
        if not self._is_running(pid):
            # Stale PID — clean up
            self._cleanup()
            raise RedictumError("Daemon is not running (stale PID file removed).")

        os.kill(pid, signal.SIGTERM)

        # Wait for process to exit
        deadline = time.monotonic() + STOP_TIMEOUT
        while time.monotonic() < deadline:
            if not self._is_running(pid):
                return
            time.sleep(0.1)

        _rprint(
            f"[yellow]Warning: daemon (PID {pid}) did not exit within "
            f"{STOP_TIMEOUT}s after SIGTERM.[/yellow]"
        )

    def status(self) -> int | None:
        """Return PID if daemon is running, None otherwise. Cleans stale PID."""
        pid = self._read_pid()
        if pid is None:
            return None
        if self._is_running(pid):
            return pid
        # Stale PID
        self._cleanup()
        return None

    @property
    def stop_event(self) -> threading.Event:
        """Event for the main loop to wait on."""
        return self._stop_event


class AudioRecorder:
    """Record microphone audio via arecord."""

    def __init__(self, output_dir: Path, device: str) -> None:
        self._output_dir = output_dir
        self._device = device
        self._process: subprocess.Popen[bytes] | None = None
        self._current_file: Path | None = None

    def start(self) -> None:
        """Begin recording audio to a timestamped WAV file."""
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        self._current_file = self._output_dir / f"rec_{ts}.wav"
        self._process = subprocess.Popen(
            [
                "arecord",
                "-D", self._device,
                "-f", "S16_LE",
                "-r", str(AUDIO_SAMPLE_RATE),
                "-c", str(AUDIO_CHANNELS),
                "-t", "wav",
                str(self._current_file),
            ],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        logging.info("Recording started: %s", self._current_file.name)

    def stop(self) -> Path | None:
        """Stop recording and return the path to the WAV file.

        Returns:
            Path to the recorded WAV file, or None on failure.
        """
        if self._process is None:
            return None
        self._process.terminate()
        try:
            self._process.wait(timeout=5)
        except subprocess.TimeoutExpired:
            self._process.kill()
            self._process.wait()
            logging.warning("arecord did not stop gracefully, killed")
        self._process = None

        path = self._current_file
        self._current_file = None
        if path is None or not path.exists() or path.stat().st_size == 0:
            logging.warning("Recording file empty or missing: %s", path)
            if path and path.exists():
                path.unlink()
            return None
        logging.info("Recording stopped: %s", path.name)
        return path

    def cancel(self) -> None:
        """Terminate recording and delete the file. For graceful shutdown."""
        if self._process is not None:
            self._process.terminate()
            try:
                self._process.wait(timeout=2)
            except subprocess.TimeoutExpired:
                self._process.kill()
                self._process.wait()
            self._process = None
        if self._current_file and self._current_file.exists():
            self._current_file.unlink()
            self._current_file = None


class AudioProcessor:
    """Normalize audio via ffmpeg."""

    def normalize(self, input_path: Path) -> Path:
        """Normalize audio levels of the given file.

        Args:
            input_path: Path to the raw audio file.

        Returns:
            Path to the normalized audio file.

        Raises:
            RedictumError: If ffmpeg fails.
        """
        output_path = input_path.with_stem(input_path.stem + "_norm")
        try:
            result = subprocess.run(
                [
                    "ffmpeg",
                    "-i", str(input_path),
                    "-af", "loudnorm",
                    "-ar", str(AUDIO_SAMPLE_RATE),
                    "-ac", str(AUDIO_CHANNELS),
                    "-y",
                    str(output_path),
                ],
                stderr=subprocess.PIPE,
                stdout=subprocess.DEVNULL,
                timeout=60,
            )
        except subprocess.TimeoutExpired as exc:
            raise RedictumError("ffmpeg normalization timed out") from exc
        if result.returncode != 0:
            raise RedictumError(
                f"ffmpeg normalization failed (code {result.returncode}): "
                f"{result.stderr.decode(errors='replace')[:200]}"
            )
        logging.info(
            "Audio normalized: %s -> %s", input_path.name, output_path.name
        )
        return output_path


def _detect_language() -> str:
    """Detect language code from system locale (e.g., 'ru', 'en', 'uk').

    Returns:
        Two-letter ISO 639-1 language code, or empty string if
        detection fails.
    """
    loc = os.environ.get("LANG", "") or os.environ.get("LC_ALL", "")
    # loc is like "ru_RU.UTF-8" or "ru_RU" or "en_US.UTF-8"
    if "_" in loc:
        return loc.split("_")[0].lower()
    if loc and len(loc) >= 2:
        return loc[:2].lower()
    return ""


class Transcriber:
    """Transcribe audio via whisper.cpp CLI."""

    BLANK_MARKERS = {"[BLANK_AUDIO]", "[ЗВУК]", "(silence)"}

    def __init__(
        self,
        whisper_cli: str,
        model_path: str,
        language: str,
        prompt: str = "",
        timeout: int = 120,
    ) -> None:
        self._cli = whisper_cli
        self._model = model_path
        self._language = language
        self._prompt = prompt
        self._timeout = timeout

    def transcribe(self, audio_path: Path, translate: bool = False) -> str:
        """Transcribe the given audio file to text.

        Args:
            audio_path: Path to the audio file.
            translate: If True, also translate to English via --translate.

        Returns:
            Transcribed text string (empty if nothing useful detected).

        Raises:
            RedictumError: If whisper-cli fails or times out.
        """
        cmd = [
            self._cli,
            "-m", self._model,
            "-f", str(audio_path),
            "--no-timestamps",
            "-np",
        ]
        if translate:
            # No -l flag: whisper auto-detects source language
            # and --translate outputs English
            cmd.append("--translate")
        elif self._language:
            cmd.extend(["-l", self._language])
        if not translate and self._prompt:
            cmd.extend(["--prompt", self._prompt])

        logging.info(
            "Transcribing: %s (translate: %s)", audio_path.name, translate,
        )

        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self._timeout,
            )
        except subprocess.TimeoutExpired as exc:
            raise RedictumError(
                f"Transcription timed out after {self._timeout}s"
            ) from exc

        if result.returncode != 0:
            raise RedictumError(
                f"whisper-cli failed (code {result.returncode}): "
                f"{result.stderr[:200]}"
            )

        text = result.stdout.strip()
        # Filter blank audio artifacts
        if not text or text in self.BLANK_MARKERS:
            logging.info("Whisper returned blank/empty output")
            return ""
        return text


class ClipboardManager:
    """Copy text to clipboard, paste via xdotool, save/restore contents.

    Supports saving and restoring text and binary clipboard data (images,
    file lists) so that the user's clipboard is preserved across paste
    operations.
    """

    # X11 protocol targets — not actual data, skip when saving.
    _SKIP_TARGETS = frozenset({
        "TARGETS", "MULTIPLE", "SAVE_TARGETS", "TIMESTAMP", "DELETE",
        "INCR", "INSERT_PROPERTY", "INSERT_SELECTION", "MANAGER",
    })

    # Target patterns we know how to save and restore.
    _SUPPORTED_PREFIXES = ("text/", "image/", "UTF8_STRING", "STRING", "TEXT")

    def copy(self, text: str) -> None:
        """Copy text to the system clipboard via xclip."""
        result = subprocess.run(
            ["xclip", "-selection", "clipboard"],
            input=text.encode("utf-8"),
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        if result.returncode != 0:
            logging.warning("xclip copy failed (code %d)", result.returncode)

    def paste(self) -> None:
        """Simulate Ctrl+V to paste from clipboard."""
        time.sleep(0.05)
        result = subprocess.run(
            ["xdotool", "key", "--clearmodifiers", "ctrl+v"],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        if result.returncode != 0:
            logging.warning("xdotool paste failed (code %d)", result.returncode)

    def save(self) -> tuple[str, bytes] | None:
        """Save current clipboard contents (target type + raw data).

        Returns:
            ``(target, data)`` tuple or ``None`` if clipboard is empty
            or contains unsupported content.
        """
        target = self._detect_target()
        if target is None:
            return None
        try:
            result = subprocess.run(
                ["xclip", "-selection", "clipboard", "-t", target, "-o"],
                capture_output=True,
                timeout=5,
            )
            if result.returncode != 0 or not result.stdout:
                logging.warning("Clipboard save failed: xclip returned %d", result.returncode)
                return None
            return (target, result.stdout)
        except (subprocess.TimeoutExpired, FileNotFoundError) as exc:
            logging.warning("Clipboard save failed: %s", exc)
            return None

    def restore(self, snapshot: tuple[str, bytes]) -> None:
        """Restore previously saved clipboard contents.

        Args:
            snapshot: ``(target, data)`` tuple from ``save()``.
        """
        target, data = snapshot
        try:
            subprocess.run(
                ["xclip", "-selection", "clipboard", "-t", target],
                input=data,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                timeout=5,
            )
        except (subprocess.TimeoutExpired, FileNotFoundError) as exc:
            logging.warning("Clipboard restore failed: %s", exc)

    def _detect_target(self) -> str | None:
        """Detect the best clipboard target to save.

        Reads the TARGETS list from xclip, filters out X11 internal
        targets, and returns the first supported one (most specific
        format as advertised by the clipboard owner).
        """
        try:
            result = subprocess.run(
                ["xclip", "-selection", "clipboard", "-t", "TARGETS", "-o"],
                capture_output=True,
                text=True,
                timeout=5,
            )
            if result.returncode != 0 or not result.stdout:
                return None
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return None

        for line in result.stdout.splitlines():
            target = line.strip()
            if not target or target in self._SKIP_TARGETS:
                continue
            if any(target.startswith(p) for p in self._SUPPORTED_PREFIXES):
                return target
        return None


class SoundNotifier:
    """Play WAV feedback tones via paplay.

    Tones are procedurally generated lazily on first play and cached as
    temporary WAV files. See ``_generate_tones()`` at the bottom
    of this module for the synthesis code.
    """

    def __init__(self, volume: int = 30) -> None:
        self._volume = max(0, min(100, volume))
        self._temp_dir: Path | None = None
        self._sounds: dict[str, Path] = {}
        self._warned_no_paplay = False

    def play_start(self) -> None:
        """Play the 'recording started' tone."""
        self._play("start")

    def play_processing(self) -> None:
        """Play the 'transcription in progress' tone."""
        self._play("processing")

    def play_stop(self) -> None:
        """Play the 'pipeline complete' tone."""
        self._play("done")

    def play_error(self) -> None:
        """Play the 'error occurred' tone."""
        self._play("error")

    def cleanup(self) -> None:
        """Remove temporary WAV files."""
        if self._temp_dir is not None:
            shutil.rmtree(self._temp_dir, ignore_errors=True)

    # -- internals -----------------------------------------------------------

    def _ensure_tones(self) -> None:
        """Generate and cache all WAV tones on first use."""
        if self._sounds:
            return
        self._temp_dir = Path(tempfile.mkdtemp(prefix="redictum_"))
        for name, samples in _generate_tones().items():
            self._sounds[name] = self._write_wav(f"{name}.wav", samples)

    def _play(self, name: str) -> None:
        self._ensure_tones()
        wav_path = self._sounds.get(name)
        if wav_path is None or not wav_path.exists():
            return
        vol_scaled = int(self._volume / 100 * 65536)
        try:
            proc = subprocess.Popen(
                ["paplay", f"--volume={vol_scaled}", str(wav_path)],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            threading.Thread(target=proc.wait, daemon=True).start()
        except FileNotFoundError:
            if not self._warned_no_paplay:
                logging.warning("paplay not found, sound notifications disabled")
                self._warned_no_paplay = True

    def _write_wav(self, filename: str, samples: list[float]) -> Path:
        peak = max(abs(s) for s in samples) or 1.0
        pcm = b"".join(
            struct.pack("<h", max(-32767, min(32767, int(s / peak * 30000))))
            for s in samples
        )
        n = len(pcm)
        header = struct.pack(
            "<4sI4s4sIHHIIHH4sI",
            b"RIFF", 36 + n, b"WAVE",
            b"fmt ", 16, 1, 1, 44100, 88200, 2, 16,
            b"data", n,
        )
        path = self._temp_dir / filename
        path.write_bytes(header + pcm)
        return path


class HotkeyListener:
    """Push-to-talk hotkey listener via pynput.

    Hold the key for hold_delay seconds to start recording.
    Release the key to trigger processing.
    """

    # Mapping of config string names to pynput Key attributes
    _KEY_MAP: dict[str, str] = {
        "insert": "insert",
        "delete": "delete",
        "home": "home",
        "end": "end",
        "page_up": "page_up",
        "page_down": "page_down",
        "space": "space",
        "enter": "enter",
        "tab": "tab",
        "backspace": "backspace",
        "pause": "pause",
        "scroll_lock": "scroll_lock",
        "print_screen": "print_screen",
        "caps_lock": "caps_lock",
        "num_lock": "num_lock",
        "escape": "esc",
        "esc": "esc",
    }

    _MODIFIER_MAP: dict[str, tuple[str, ...]] = {
        "ctrl":  ("ctrl_l", "ctrl_r"),
        "alt":   ("alt_l", "alt_r", "alt_gr"),
        "shift": ("shift_l", "shift_r"),
    }

    def __init__(self, hotkey: str, hold_delay: float, translate_key: str = "") -> None:
        self._hotkey = hotkey
        self._translate_key = translate_key
        self._hold_delay = hold_delay
        self._target_key: Any = None
        self._target_mods: frozenset[Any] = frozenset()
        self._translate_target_key: Any = None
        self._translate_target_mods: frozenset[Any] = frozenset()
        self._held_mods: set[Any] = set()
        self._all_mod_keys: frozenset[Any] = frozenset()
        self._listener: Any = None
        self._hold_timer: threading.Timer | None = None
        self._is_holding = False
        self._pending_mode: str = "transcribe"
        self._on_hold: Callable[[str], None] | None = None
        self._on_release: Callable[[str], None] | None = None

    def start(self, on_hold: Callable[[str], None], on_release: Callable[[str], None]) -> None:
        """Start listening for the push-to-talk hotkey.

        Args:
            on_hold: Called with mode ("transcribe"/"translate") when key
                     is held longer than hold_delay.
            on_release: Called with mode when key is released after hold.
        """
        from pynput.keyboard import Key, Listener

        self._on_hold = on_hold
        self._on_release = on_release
        self._target_key, self._target_mods = self._parse_combo(self._hotkey)
        if self._translate_key:
            self._translate_target_key, self._translate_target_mods = \
                self._parse_combo(self._translate_key)
        # Collect all pynput Key objects for modifiers
        all_mods: set[Any] = set()
        for key_names in self._MODIFIER_MAP.values():
            for name in key_names:
                if hasattr(Key, name):
                    all_mods.add(getattr(Key, name))
        self._all_mod_keys = frozenset(all_mods)
        self._listener = Listener(
            on_press=self._on_press,
            on_release=self._on_key_release,
        )
        self._listener.start()
        logging.info(
            "Hotkey listener started: %s (hold %.1fs), translate: %s",
            self._hotkey, self._hold_delay, self._translate_key or "disabled",
        )

    def stop(self) -> None:
        """Stop the hotkey listener and cancel any pending timer."""
        if self._hold_timer is not None:
            self._hold_timer.cancel()
            self._hold_timer = None
        if self._listener is not None:
            self._listener.stop()
            self._listener = None

    def _on_press(self, key: Any) -> None:
        """Handle key press: track modifiers and start hold timer."""
        if key in self._all_mod_keys:
            self._held_mods.add(key)
            return
        mode = self._resolve_mode(key)
        if mode is None:
            return
        if self._is_holding or self._hold_timer is not None:
            return
        self._pending_mode = mode
        self._hold_timer = threading.Timer(self._hold_delay, self._fire_hold)
        self._hold_timer.daemon = True
        self._hold_timer.start()

    def _fire_hold(self) -> None:
        """Called when hold_delay expires — trigger on_hold callback."""
        self._is_holding = True
        self._hold_timer = None
        if self._on_hold:
            self._on_hold(self._pending_mode)

    def _on_key_release(self, key: Any) -> None:
        """Handle key release: track modifiers, cancel timer or trigger on_release."""
        if key in self._all_mod_keys:
            self._held_mods.discard(key)
            return
        if not (key == self._target_key or key == self._translate_target_key):
            return
        if self._hold_timer is not None:
            self._hold_timer.cancel()
            self._hold_timer = None
        if self._is_holding:
            self._is_holding = False
            if self._on_release:
                self._on_release(self._pending_mode)

    def _resolve_mode(self, key: Any) -> str | None:
        """Determine mode from pressed key + held modifiers.

        Priority: translate (more specific combo) > transcribe.
        """
        if (self._translate_target_key is not None
                and key == self._translate_target_key
                and self._mods_match(self._translate_target_mods)):
            return "translate"
        if key == self._target_key and self._mods_match(self._target_mods):
            return "transcribe"
        return None

    def _mods_match(self, required_mods: frozenset[Any]) -> bool:
        """Check EXACT match of modifier groups (ctrl, alt, shift)."""
        from pynput.keyboard import Key
        for key_names in self._MODIFIER_MAP.values():
            group = frozenset(
                getattr(Key, n) for n in key_names if hasattr(Key, n)
            )
            group_required = bool(required_mods & group)
            group_held = bool(self._held_mods & group)
            if group_required != group_held:
                return False
        return True

    @classmethod
    def _parse_combo(cls, combo: str) -> tuple[Any, frozenset[Any]]:
        """Parse "ctrl+Insert" into (Key.insert, frozenset({Key.ctrl_l, Key.ctrl_r}))."""
        from pynput.keyboard import Key
        parts = [p.strip() for p in combo.split("+")]
        modifier_strings = parts[:-1]
        key_string = parts[-1]
        mods: set[Any] = set()
        for mod_str in modifier_strings:
            normalized = mod_str.lower()
            if normalized not in cls._MODIFIER_MAP:
                raise RedictumError(f"Unknown modifier: '{mod_str}'")
            for attr in cls._MODIFIER_MAP[normalized]:
                if hasattr(Key, attr):
                    mods.add(getattr(Key, attr))
        trigger = cls._parse_key(key_string)
        return trigger, frozenset(mods)

    @classmethod
    def _parse_key(cls, hotkey: str) -> Any:
        """Parse a hotkey string into a pynput Key or KeyCode.

        Supports: "Insert", "F1"-"F20", single characters ("a", "b"), etc.
        """
        from pynput.keyboard import Key, KeyCode

        normalized = hotkey.strip().lower()

        # Function keys: f1-f20
        if normalized.startswith("f") and normalized[1:].isdigit():
            attr = normalized
            if hasattr(Key, attr):
                return getattr(Key, attr)

        # Named keys
        if normalized in cls._KEY_MAP:
            return getattr(Key, cls._KEY_MAP[normalized])

        # Single character
        if len(hotkey.strip()) == 1:
            return KeyCode.from_char(hotkey.strip())

        raise RedictumError(f"Unknown hotkey: '{hotkey}'")


class Housekeeping:
    """Rotate old audio and transcript files."""

    def __init__(
        self,
        audio_dir: Path,
        transcripts_dir: Path,
        logs_dir: Path,
        storage_cfg: dict[str, Any],
    ) -> None:
        self._audio_dir = audio_dir
        self._transcripts_dir = transcripts_dir
        self._logs_dir = logs_dir
        self._audio_max = storage_cfg.get("audio", {}).get("max_files", 50)
        self._transcripts_max = storage_cfg.get("transcripts", {}).get("max_files", 50)
        self._logs_max = storage_cfg.get("logs", {}).get("max_files", 50)

    def rotate_audio(self) -> int:
        """Remove oldest audio files exceeding the limit.

        Returns:
            Number of files removed.
        """
        wav_files = sorted(
            self._audio_dir.glob("*.wav"),
            key=lambda p: p.stat().st_mtime,
        )
        return self._rotate(wav_files, self._audio_max, "Audio")

    def rotate_transcripts(self) -> int:
        """Remove oldest daily transcript files exceeding the limit.

        Returns:
            Number of files removed.
        """
        txt_files = sorted(
            self._transcripts_dir.glob("*.txt"),
            key=lambda p: p.stat().st_mtime,
        )
        return self._rotate(txt_files, self._transcripts_max, "Transcript")

    def rotate_logs(self) -> int:
        """Remove oldest session log files exceeding the limit.

        Returns:
            Number of files removed.
        """
        log_files = sorted(
            self._logs_dir.glob("*.log"),
            key=lambda p: p.stat().st_mtime,
        )
        return self._rotate(log_files, self._logs_max, "Log")

    @staticmethod
    def _rotate(files: list[Path], max_files: int, label: str) -> int:
        """Remove oldest files exceeding *max_files*."""
        excess = len(files) - max_files
        if excess <= 0:
            return 0
        removed = 0
        for path in files[:excess]:
            try:
                path.unlink()
                removed += 1
            except OSError:
                logging.warning("Failed to remove %s", path)
        if removed:
            logging.info("%s rotation: removed %d old file(s)", label, removed)
        return removed


def _log_transcript(transcripts_dir: Path, text: str) -> None:
    """Append transcript to a daily file transcripts/YYYY-MM-DD.txt."""
    date_str = datetime.now().strftime("%Y-%m-%d")
    log_file = transcripts_dir / f"{date_str}.txt"
    timestamp = datetime.now().strftime("%H:%M:%S")
    with open(log_file, "a", encoding="utf-8") as f:
        f.write(f"[{timestamp}] {text}\n")


# ---------------------------------------------------------------------------
# RedictumApp — orchestrator
# ---------------------------------------------------------------------------

class RedictumApp:
    """Main application orchestrator that wires all components together."""

    def __init__(self, script_dir: Path) -> None:
        self._script_dir = script_dir
        self._config_mgr = ConfigManager(script_dir)
        self._dir_mgr = DirectoryManager(script_dir)
        self._pid_path = script_dir / PID_FILENAME
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        self._log_path = script_dir / "logs" / f"redictum_{ts}.log"
        self._init_marker = script_dir / INITIALIZED_FILENAME
        self._config: dict[str, Any] = {}

    def _is_initialized(self) -> bool:
        """Check if the first-run marker file exists."""
        return self._init_marker.exists()

    def _mark_initialized(self) -> None:
        """Create the first-run marker file."""
        self._init_marker.write_text(
            f"initialized {datetime.now().isoformat()}\n"
        )

    def init(self) -> dict[str, Any]:
        """Initialize config, directories, and run diagnostics.

        Returns:
            Loaded configuration dictionary.

        Raises:
            RedictumError: If a critical dependency is missing.
        """
        config = self._config_mgr.load()
        self._dir_mgr.ensure()
        diag = Diagnostics(config, self._config_mgr)
        diag.run_stage1()
        diag.run_stage2()
        diag.check_whisper()
        self._mark_initialized()
        # Reload config — check_whisper() may have updated paths on disk
        return self._config_mgr.load()

    def init_quick(self) -> dict[str, Any]:
        """Load config and ensure directories without running diagnostics.

        Returns:
            Loaded configuration dictionary.
        """
        config = self._config_mgr.load()
        self._dir_mgr.ensure()
        return config

    def _deps_ok(self, config: dict[str, Any]) -> bool:
        """Silently check that all critical dependencies are present."""
        # Stage 1: critical environment
        if sys.version_info < (3, 10):
            return False
        if sys.platform != "linux":
            return False
        if not shutil.which("paplay"):
            return False
        if not shutil.which("arecord"):
            return False
        if not os.environ.get("DISPLAY"):
            return False
        # Stage 2: apt packages (runtime only, build tools skipped)
        for name in APT_PACKAGES:
            if not shutil.which(name):
                return False
        # Stage 2: pip packages
        for import_name in PIP_PACKAGES:
            try:
                __import__(import_name)
            except ImportError:
                return False
        # whisper.cpp
        whisper = config.get("dependency", {}).get("whisper", {})
        cli_path = whisper.get("cli", "")
        model_path = whisper.get("model", "")
        if not cli_path or not Path(cli_path).exists():
            return False
        if not model_path or not Path(model_path).exists():
            return False
        return True

    def _print_banner(self, ready: bool = False) -> None:
        """Print compact startup banner with hotkeys and language info."""
        if ready:
            _rprint("[bold green]Redictum Terminal — ready![/bold green]")
        else:
            _rprint("[bold]Redictum Terminal[/bold]")

        # Resolve hotkey names from config
        hotkey_cfg = self._config.get("input", {}).get("hotkey", {})
        key = hotkey_cfg.get("key", "Insert")
        translate_key = hotkey_cfg.get("translate_key", "")
        parts = [f"{key} (transcribe)"]
        if translate_key:
            parts.append(f"{translate_key} (translate)")
        _rprint(f"Listening: {', '.join(parts)}")

        # Resolve language
        whisper_cfg = self._config.get("dependency", {}).get("whisper", {})
        language = whisper_cfg.get("language", "auto")
        if language == "auto":
            detected = _detect_language()
            _rprint(f"Language: {detected} (auto)")
        else:
            _rprint(f"Language: {language}")

        _rprint("\nPress Ctrl+C to stop.")

    def _show_config_hint(self) -> None:
        """Show config file location and examples after first run."""
        _rprint(f"\n[bold]Configuration:[/bold] {self._config_mgr.path}")
        _rprint("  Examples:")
        _rprint('    \u2022 Change hotkey:   [cyan]key: "F12"[/cyan]          (default: Insert)')
        _rprint('    \u2022 Change language: [cyan]language: "en"[/cyan]      (default: auto)')

    def run_interactive(self) -> int:
        """Run in interactive (foreground) mode.

        Returns:
            Exit code.
        """
        first_run = not self._is_initialized()
        if not first_run:
            self._config = self.init_quick()
            if self._deps_ok(self._config):
                ready = False
            else:
                self._config = self.init()
                ready = True
        else:
            self._config = self.init()
            ready = True

        if first_run:
            self._show_config_hint()

        setup_logging(self._log_path)

        stop_event = threading.Event()

        def handle_signal(signum: int, frame: Any) -> None:
            stop_event.set()

        signal.signal(signal.SIGINT, handle_signal)
        signal.signal(signal.SIGTERM, handle_signal)

        self._print_banner(ready=ready)
        logging.info("Interactive mode started (PID %d)", os.getpid())
        self._main_loop(stop_event)
        logging.info("Interactive mode stopped.")
        return EXIT_OK

    def run_start(self) -> int:
        """Start the daemon.

        Returns:
            Exit code.
        """
        first_run = not self._is_initialized()
        if not first_run:
            self._config = self.init_quick()
            if not self._deps_ok(self._config):
                self._config = self.init()
        else:
            self._config = self.init()

        if first_run:
            self._show_config_hint()

        daemon = Daemon(self._pid_path, self._log_path)
        _rprint("[bold]Redictum Terminal — daemon started.[/bold]")

        def target() -> None:
            self._main_loop(daemon.stop_event)

        daemon.start(target=target)
        return EXIT_OK

    def run_stop(self) -> int:
        """Stop the daemon.

        Returns:
            Exit code.
        """
        daemon = Daemon(self._pid_path, self._log_path)
        daemon.stop()
        _rprint("[green]Daemon stopped.[/green]")
        return EXIT_OK

    def run_status(self) -> int:
        """Print daemon status.

        Returns:
            Exit code.
        """
        daemon = Daemon(self._pid_path, self._log_path)
        pid = daemon.status()
        if pid is not None:
            _rprint(f"[green]Daemon is running[/green] (PID {pid})")
        else:
            _rprint("[yellow]Daemon is not running.[/yellow]")
        return EXIT_OK

    def run_whisper(self) -> int:
        """Setup whisper.cpp: install, check, or reconfigure.

        Returns:
            Exit code.
        """
        self._config = self._config_mgr.load()
        self._dir_mgr.ensure()
        installer = WhisperInstaller(self._config_mgr)
        installer.install()
        return EXIT_OK

    def _main_loop(self, stop_event: threading.Event) -> None:
        """Main loop: push-to-talk → record → normalize → transcribe → paste."""
        cfg = self._config
        audio_dir = self._script_dir / "audio"
        transcripts_dir = self._script_dir / "transcripts"

        # Unpack nested config sections
        whisper = cfg["dependency"]["whisper"]
        audio = cfg["audio"]["recording"]
        hotkey = cfg["input"]["hotkey"]
        clip_cfg = cfg["clipboard"]["paste"]
        sound_cfg = cfg["notification"]["sound"]
        storage = cfg["storage"]

        # Resolve language: "auto" -> detect from system locale
        language = whisper.get("language", "auto")
        if language == "auto":
            language = _detect_language()
            logging.info("Language auto-detected from locale: %r", language)

        # Build pipeline components
        recorder = AudioRecorder(audio_dir, audio["device"])
        processor = AudioProcessor()
        transcriber = Transcriber(
            whisper["cli"],
            whisper["model"],
            language,
            prompt=whisper.get("prompt", ""),
            timeout=whisper.get("timeout", 120),
        )
        clipboard = ClipboardManager()
        notifier = SoundNotifier(volume=sound_cfg.get("signal_volume", 30))
        logs_dir = self._log_path.parent
        housekeeper = Housekeeping(audio_dir, transcripts_dir, logs_dir, storage)
        listener = HotkeyListener(
            hotkey["key"], hotkey["hold_delay"],
            translate_key=hotkey.get("translate_key", ""),
        )

        state = STATE_IDLE
        state_lock = threading.Lock()
        _current_mode = "transcribe"

        def on_hold(mode: str) -> None:
            nonlocal state, _current_mode
            with state_lock:
                if state != STATE_IDLE:
                    return
                state = STATE_RECORDING
                _current_mode = mode
            recorder.start()
            if sound_cfg.get("signal_start", True):
                notifier.play_start()
            logging.info("Recording started (mode: %s)", mode)

        def on_release(mode: str) -> None:
            nonlocal state
            with state_lock:
                if state != STATE_RECORDING:
                    return
                state = STATE_PROCESSING
            captured_mode = _current_mode

            def worker() -> None:
                nonlocal state
                try:
                    audio_path = recorder.stop()
                    if sound_cfg.get("signal_processing", False):
                        notifier.play_processing()
                    if audio_path is None:
                        logging.warning("Recording produced no audio")
                        return

                    # Normalize
                    if audio.get("normalize", True):
                        try:
                            audio_path = processor.normalize(audio_path)
                        except RedictumError:
                            logging.exception("Normalization failed, using raw audio")

                    # Transcribe
                    text = transcriber.transcribe(
                        audio_path,
                        translate=(captured_mode == "translate"),
                    )
                    if not text:
                        logging.info("Transcription returned empty text")
                        return

                    logging.info("Transcribed (mode: %s): %d chars", captured_mode, len(text))

                    # Apply prefix/postfix
                    prefix = clip_cfg.get("prefix", "")
                    postfix = clip_cfg.get("postfix", "")
                    final_text = f"{prefix}{text}{postfix}"

                    # Log transcript
                    _log_transcript(transcripts_dir, final_text)

                    # Clipboard: save → copy → paste → restore
                    if clip_cfg.get("auto", True):
                        saved = clipboard.save()
                        clipboard.copy(final_text)
                        clipboard.paste()
                        # Restore previous clipboard after a short delay
                        time.sleep(0.2)
                        if saved:
                            clipboard.restore(saved)
                    else:
                        clipboard.copy(final_text)

                    if sound_cfg.get("signal_done", True):
                        notifier.play_stop()
                    housekeeper.rotate_audio()
                    housekeeper.rotate_transcripts()
                    housekeeper.rotate_logs()
                    logging.info("Pipeline complete, state -> idle")
                except RedictumError:
                    logging.exception("Pipeline error")
                    if sound_cfg.get("signal_error", True):
                        notifier.play_error()
                except Exception:
                    logging.exception("Unexpected pipeline error")
                    if sound_cfg.get("signal_error", True):
                        notifier.play_error()
                finally:
                    with state_lock:
                        state = STATE_IDLE

            thread = threading.Thread(target=worker, daemon=True)
            thread.start()

        listener.start(on_hold, on_release)

        # Wait for shutdown signal
        stop_event.wait()

        # Graceful shutdown
        listener.stop()
        if notifier:
            notifier.cleanup()
        with state_lock:
            current = state
        if current == STATE_RECORDING:
            recorder.cancel()
            logging.info("Cancelled recording during shutdown")
        elif current == STATE_PROCESSING:
            logging.info("Waiting for processing to finish...")
            deadline = time.monotonic() + 30
            while time.monotonic() < deadline:
                with state_lock:
                    if state == STATE_IDLE:
                        break
                time.sleep(0.5)

        logging.info("Main loop stopped")


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------

def build_parser() -> argparse.ArgumentParser:
    """Build and return the argument parser.

    Returns:
        Configured ArgumentParser instance.
    """
    parser = argparse.ArgumentParser(
        prog="redictum",
        description="Redictum Terminal — voice-to-text CLI for Linux.",
    )
    parser.add_argument(
        "--version",
        action="version",
        version=f"redictum {VERSION}",
    )
    parser.add_argument(
        "--config",
        action="store_true",
        help="Recreate config.yaml with default values",
    )
    sub = parser.add_subparsers(dest="command")

    sub.add_parser("start", help="Start the daemon")
    sub.add_parser("stop", help="Stop the daemon")
    sub.add_parser("status", help="Show daemon status")
    sub.add_parser("whisper", help="Setup whisper.cpp (install, check, reconfigure)")

    return parser


def main() -> int:
    """Entry point for Redictum Terminal.

    Returns:
        Exit code (0 = success, 1 = error).
    """
    parser = build_parser()
    args = parser.parse_args()

    script_dir = Path(__file__).resolve().parent
    app = RedictumApp(script_dir)

    if args.config:
        config_path = script_dir / "config.yaml"
        if config_path.exists():
            config_path.unlink()
        init_marker = script_dir / INITIALIZED_FILENAME
        if init_marker.exists():
            init_marker.unlink()

    try:
        if args.command is None:
            return app.run_interactive()
        if args.command == "start":
            return app.run_start()
        if args.command == "stop":
            return app.run_stop()
        if args.command == "status":
            return app.run_status()
        if args.command == "whisper":
            return app.run_whisper()
    except RedictumError as exc:
        print(f"Error: {exc}", file=sys.stderr)
        return EXIT_ERROR

    return EXIT_OK


# ---------------------------------------------------------------------------
# Tone synthesis (used by SoundNotifier)
# ---------------------------------------------------------------------------
# Each tone is a list of float samples in [-1, 1] range.  Synthesis uses
# additive sine waves with exponential envelopes to produce short, distinct
# notification sounds.  The helpers below are intentionally compact — they
# run once at startup and the output is cached as WAV files.

def _generate_tones() -> dict[str, list[float]]:
    """Return ``{name: samples}`` for all notification sounds."""
    sr = 44100
    _s = lambda f, t: math.sin(2 * math.pi * f * t)  # noqa: E731
    _e = math.exp                                      # noqa: E731

    def _beep(freq: float) -> list[float]:
        """Single short beep at *freq* Hz (used by 'start')."""
        n = int(sr * 0.04)
        return [(1 - _e(-800 * t)) * _e(-20 * t) * _s(freq, t)
                for i in range(n) for t in [i / sr]]

    gap = [0.0] * int(sr * 0.03)

    return {
        # Three ascending beeps — recording started
        "start": _beep(1000) + gap + _beep(1300) + gap + _beep(1600),

        # Metallic tick with inharmonic overtones — transcription started
        "processing": [
            _e(-25 * t) * (1 - _e(-800 * t))
            * (0.5 * _s(900, t) + 0.3 * _s(2160, t) + 0.2 * _s(3690, t))
            for i in range(int(sr * 0.08)) for t in [i / sr]
        ],

        # Glass tap with shimmering harmonics — result pasted
        "done": [
            _e(-8 * t) * (1 - _e(-2000 * t))
            * (0.4 * _s(2200, t)
               + 0.3 * _s(3300, t) * _e(-10 * t)
               + 0.2 * _s(5940, t) * _e(-15 * t)
               + 0.1 * _s(9460, t) * _e(-20 * t))
            for i in range(int(sr * 0.2)) for t in [i / sr]
        ],

        # Low buzz with harmonics — error
        "error": [
            (1 - t / 0.25) * (1 - _e(-300 * t))
            * (0.4 * _s(150, t) + 0.3 * _s(300, t)
               + 0.2 * _s(450, t) + 0.1 * _s(750, t))
            for i in range(int(sr * 0.25)) for t in [i / sr]
        ],
    }


if __name__ == "__main__":
    sys.exit(main())
